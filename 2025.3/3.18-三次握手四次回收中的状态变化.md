# 三次握手四次回收中的状态变化

![image-20250318165920480](C:\Users\姜雨奇\AppData\Roaming\Typora\typora-user-images\image-20250318165920480.png)

```c
// tcp 通信的状态变化
///////////三次握手///////////
// 先启动服务器 -> 绑定 -> 设置监听 listen()
	服务器端的状态变化: 无状态 -> LISTEN
// 状态变化是从三次握手开始的(客户端发起连接)
第一次握手:
	客户端:
		给服务器发送 SYN, 无状态 -> SYN_SENT
	服务器:
		接收数据, 状态 LISTEN
第二次握手:
	服务器: 给客户端回复 ACK, 并发送连接请求 SYN, 状态: LISTEN -> SYN_RCVD
    客户端: 收到服务器的 ACK, 状态: SYN_SENT-> ESTABLISED
第三次握手:
	客户端: 回复 ACK, 状态无变化
   	服务器: 接收 ACK, 状态: SYN_RCVD -> ESTABLISED
```

```cpp
在双向连接建立后,通信过程中 tcp 的状态不会发生变化, 都是 SETABLISED
```

```cpp
///////////四次挥手///////////
第一次挥手:
	客户端: 
		1. 调用了 close() 函数,相当于在 tcp 协议中将 FIN 设置为 1
    	2. 状态变化: ESTABLISED -> FIN_WAIT_1
    服务器: 
		状态无变化: ESTABLISED
第二次挥手:
	服务器: 收到 FIN, 回复 ACK, 状态变化: ESTABLISED -> CLOSE_WAIT	
	服务器: 收到 ACK, 状态变为 FIN_WAIT_2
第三次挥手:
	服务器: 给客户端发送断开连接的请求, 状态变化: CLOSE_WAIT-> LAST_ACK
	客户端: 收到服务器断开连接的请求 FIN, 状态变化: FIN_WAIT_2 -> TIME_WAIT
第四次挥手:
	客户端: 回复 ACK, 状态没变 还是 TIME_WAIT (生命周期还没结束) --> 主动断开连接的一方
    - TIME_WAIT会持续一段时间, 时间到达后, 变为无状态, 生命周期结束
    服务器: 收到 ACK, 状态 LAST_ACK -> 无状态 --> 被动断开连接的一方
```

```cpp
# 2MSL 是什么
	- Maximum Segment Lifetime ~ 30s
    - 2MSL 大约是一分钟

四次挥手第三次挥手完成之后,
	主动断开的一方最后变成: TIME_WAIT 状态
    被动断开的一方, 状态为u: KAST_ACK
        - 必须等待对端回复一个 ACK, 状态才能清零
        - 假设说对方变成 TIME_WAIT 之后, 马上就推出了, 变成了无状态, 无法继续和被动连接的一方通信, 如果回复的 ACK 丢了, 被动断开连接的一方会一直处于 LAST_ACK 状态
    等待的原因:
		处于 TIME_WAIT 的进程回复 ACK 之后, 被动断开连接的一方没有收到 ACK
       	会再次给处于 TIME_WAIT 状态的进程发送 FIN, 会再次回复 ACk
        欸东段开连接的一方也就是处于 LAST_ACK 的状态进程收到了 ACK, tcp 状态就关闭了, 生命周期就结束了
```

+ 半关闭

```cpp
四次挥手过程只完成了两次, 相当于其中一段调用了 close() 函数, 另外一段没有调用
这个时候的状态就成为半关闭
    
当程序做了半关闭之后:
	假设: 在服务器端调用了 close() 函数, 但是在客户端没有调用, 实现了半关闭, 连接从双向变成单向
    通信: 
		服务器端:
			调用了 close(), 这时候服务器只能读不能写
                - close() 关闭了服务器的写操作
        客户端:
			客户端和服务器的连接还保持着
            客户端可以给服务器发送数据, 也可以接收服务器回复的数据
            	- 实际上服务器端已经关闭了写的操作, 客户端是接受不到数据的
            数据的流动方向: 客户端 --> 服务器
                
专门处理半关闭的函数:
int shutdown(int sockfd, int how);
	
	+ SHUT_RD: 关闭文件描述符的读操作
    + SHUT_WR: 关闭文件描述符的写操作
    + SHUT_RDWR: 关闭文件描述符的读写操作
```

# 端口复用

```cpp
// 启动服务器的时候错误提示: bind error : address already in use
// 服务器程序启动流程:
	1. 创建监听套接字
    2. 监听的套接字绑定在本地 IP 和端口
    3. 设置监听
    4. ...
        
// 当用户先关闭服务器连接, 服务器最后会处于 TIIME_WAIT状态, 处于这个状态的进程会有 2MSL 的等待时长
// 在等待过程中进程没有退出, 颁订的端口不会被释放, 如果不释放这个端口和其他进程进行绑定, 结果是失败的, 默认情况下一个端口不能同时被两个进程使用
        
// 解决方式: 设置端口复用

// 设置套接字选项的函数
// 选项: 端口复用, 广播, 组播, ...
```

```cpp
端口复用应该写到程序的什么位置? --> 设置到绑定之前
	1. 创建监听套接字
    	-- 设置端口复用
    2. 监听的套接字绑定在本地 IP 和端口
    3. 设置监听
    4. 等待并接收客户端连接
    5. 通信
    6. 关闭套接字
```

