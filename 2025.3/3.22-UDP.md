# UDP

```c
/*
udp: 传输层协议, 和 tcp 是一样的
特点:
	面向无连接的, 不安全的, 报式传输协议
	1. 无连接: udp 通信的时候不需要 connect
		1) 通信不需要建立连接
		2) 如果只想给对方发送数据, 只需要指定对方 IP 和端口
    2. udp 会丢包
    	1) 数据丢失了就没有了没有数据校验机制
    	2) udp 丢包不会丢失一部分, 丢就是全丢
    3. 报式:
    	发送端发送多少数据, 接收端就接受多少数据
*/
```

+ 通信流程

> udp 通信的过程中客户端和服务器的操作几乎是一样的, 地位是对等的

+ 通信流程

  + 服务器端

    ```c
    // 1. 创建一个通信的套接字
    int cfd = socket(AF_INET, SOCK_DGRM, 0);
    // 2. 通信的套接字和本地的 IP 和端口绑定
    // 绑定的目的: 程序启动以后不主动发数据, 先接受数据, 就需要绑定端口, 主动发数据, 就可以不绑定
    struct sockaddr_in addr
    bind(cfd, (struct sockaddr)&addr, sizeof addr);
    // 3. 通信
    接收数据: recvfrom();
    发送数据: sendto();
    // 4. 关闭通信的文件描述符
    close();
    ```

  + 客户端

    ```c
    // 1. 创建一个通信的套接字
    int cfd = socket(AF_INET, SOCK_DGRM, 0);
    // 2. 通信的套接字和本地的 IP 和端口绑定
    // 绑定的目的: 程序启动以后不主动发数据, 先接受数据, 就需要绑定端口
    struct sockaddr_in addr
    bind(cfd, (struct sockaddr)&addr, sizeof addr);
    // 3. 通信
    接收数据: recvfrom();
    发送数据: sendto();
    // 4. 关闭通信的文件描述符
    close();
    ```

    

+ 操作函数

  ```c
  // 接收数据
  ssize_t recvfrom(int sockfd, void buf, size_t len, int flags,
                  struct sockaddr * src_addr, socklen_t * addrlen);
  参数:
  	- socket: 通信的文件描述符
      - buf: 指向一块有效的内存地址, 存储接收的数据
  	- len: 参数 buf 指向的内存大小
      - flags: 使用默认属性, 指定为 0 即可
      - src_addr: 传出参数, 保存发送端的地址信息 -> 大端
      - addrlen: 传入传出参数, 类似于 accept() 最后一个参数
  返回值:
  	> 0: 接收的字节数
  	-1: 失败
  // 发送数据
  ssize_t sendto(int sockfd, const void buf, size_t len, int flags,
        const struct sockaddr *dest_addr, socklen_t addrlen);
  参数:
  	- socket: 通信的文件描述符
      - buf: 指向一块有效的内存地址, 内存中存储了待发送的数据
  	- len: 参数 buf 指向的内存中待发送的数据
      - flags: 使用默认属性, 指定为 0 即可
      - src_addr: 传入参数, 保存接收端的地址信息 -> 大端
      - addrlen: 传入参数, dest_addr 对应的内存大小
  返回值:
  	> 0: 接收的字节数
  	-1: 失败
  ```

+ UDP 的两个特性(TCP 没有)

  + 广播
  + 组播(多播)


# 广播

> + 有一个 UDP 的程序, 通过这个程序发送消息, 可以同时有多个接收端同时收到消息
>   + 广播是一对多, 1 : N
>     + 广播的数据要发送到广播地址上
>     + 如果是一对一发送, 使用的是这个接收端使用的实际 IP 地址
>   + 广播需要使用一个特殊的广播地址
>     + 192.168.x.255
>       + x -> 代表的是一个网段
>       + 点分十进制的最后一部分(最后一个字节)
>         + 取值范围 0 - 255, 代表这个网段最多支持多少台计算机
>   + 广播只能在局域网范围内用, 广域网是不支持广播的
>   + 广播特点:
>     1. 开销很小, 只是使用了广播地址, 数据就可以发送到多个终端上
>     1. 只能在局域网范围内使用
>     1. 发送广播的一端必须要设置广播属性

+ 通信流程

  + 数据发送端 -> 只有一个

    ```c
    // 1. 创建通信的套接字
    int fd = socket(AF_INET, SOCK_DGRM, 0);
    // 2. 因为是主动发数据, 因此不需要手动绑定端口(随机自动绑定即可)
    //	需要设置广播的属性, 通过 setsockopt() 函数 ->不设置不能广播
    // 3. 初始化接受端的地址信息
    // IP 地址: 广播地址 -> 192.168.x.255
    // port: 接受广播的一端绑定的固定端口
    sendto();
    // 3. 关闭套接字
    close();
    ```
    
  + 数据接收端 -> 有 N 个
  
    ```c
    // 1. 创建通信的套接字
    int fd = socket(AF_INET, SOCK_DGRM, 0);
    // 2. 被动接收数据, 需要手动绑定端口
    bind();
    // 3. 接收数据
    recvfrom();
    // 4. 关闭套接字
    close();
    ```
  
  + 设置广播属性
  
    ```c
    // 广播属性设置
    int setsockopt(int socket, int level, int optname,
                  const void *optval, socklen_t optlen);
    参数:
    	- sockfd: 通信的套接字
        - level: SOL_SOCKET
        - optname: SO_BROADCAST
       	- optval: int
            - 1: 允许广播
            - 0: 不允许广播
        - oplen: sizeof int
    ```

# 组播

> + 可以在广域网中使用
> + 如果不想收发送的消息, 可以使用组播
>   + 原理: 需要在发送端建一个群, 如果不想收可以不加群
>   + 基于这个原理可以实现远程会议, 需要在 INTERNET 中传输
> + 组播需要使用组播地址
>   + 发消息的人需要把消息发送到组播地址上
>   + 接受消息的人需要加入到组播地址
> + 组播属性需要手动设置
> + 加入到组播地址
