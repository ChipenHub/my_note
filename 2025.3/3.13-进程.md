# 进程

## 进程和程序

+ 程序：编译好的二进制文件，不占用系统资源（内存）。
+ 进程：活跃的程序，不消耗系统图资源（内存）。

## MMU
![image-20250313164209085](C:\Users\姜雨奇\AppData\Roaming\Typora\typora-user-images\image-20250313164209085.png)

## PCB 进程控制块
+ 本质：结构体：struct task_struct { ... }
+ 大致内容：
   + 进程id
   + 进程状态：初始态、就绪态、运行态、挂起态（阻塞）、中止态
   + 进程切换时需要保存cpu寄存器值
   + 当前工作目录
   + umask 掩码
   + 用户id，组id
   + 文件描述符表
   + 信号相关：未决信号集、信号屏蔽字
   + 进程可以使用的资源上限

## 进程状态
+ 就绪态：完成准备，等待 cpu 划分时间片，得以执行。
+ 运行态：获取cpu时间片，正则运算。
+ 挂起态：等待除 cpu 以外的其他资源。在这种进程状态，会主动放弃 cpu 使用权，提高系统 cpu 利用率。
+ 停止态：正常、异常终止进程。

## 环境变量
+ 使用命令 env 查看系统所有环境变量。
+ 环境变量语法格式：名 = 值 : 值 : 值 ...
+ echo $环境变量名

## fork 函数
```c
pid_t fork(void);
成功：
fork 之后会产生一个子进程。父子进程各自对 fork 函数做返回。
	父进程：返回子进程 id
	子进程：返回 0
失败：
	不产生子进程
	返回 -1
```

## 进程控制
+ ps aux | grep 关键字。——搜索系统中包含关键字的进程。
+ ./a.out 进程的父进程 bash
+ 系统调用和库函数的区别：
   + 系统调用：访问内核数据结构，访问硬件资源二者之一。
   + 库函数：二者均无。

## fork 后父子进程异同
​	父子相同：
+ 全局变量、.data、. text、栈、堆、环境变量、用户id、进程工作目录、宿主目录、信号处理方式……

  父子不同：

+ 进程id（pid）、fork 返回值、进程运行时间、父进程id、闹钟（定时器）、未决信号集。

## 读时共享，写时复制
+ fork后，对于父进程的用户空间的数据，系统采用**读时共享，写时复制**。
+ 父子进程共享的：
   1. 文件描述符（对应打开的文件结构体）
   2. mmap 创建的映射区

## exec函数族
+ 工作原理：
	+ 将当前进程的.text、 .data ... 替换为所要加载程序的 .text、data.　……，然后将进程从新的.text第一条指令开始执行。但进程 ID 不变。
+ 工作特性：
	+ exec 函数族函数，一旦调用成功执行新程序，不会返回！只有调用失败才返回，错误值 -1，errno
	+ 通常使用时我们只需在execxxx()函数后，调用perror 和 exit，无需if判断。

### execlp
+ p：PATH 的意思。该函数使用时，自动借助环境变量 PATH，寻找可执行程序。
	+ 可以用来调用系统的程序。
```c
int execlp(const char *file, const char *arg, .../* (char  *) NULL */);
参数：
	参 1：待加载的程序名字。需要配合 PATH 使用。
	参 2：argv0 —— 可执行文件名
	参 3：argv1
	参 4：argv1
	...
返回值：
	成功：不返回
	失败：-1，errno
该函数通常用来调用系统函数。
```
### execl
直接调用指定程序。



## 进程回收

+ fork 后的子进程，其父进程有义务在子进程结束时，回收该子进程。隔辈进程无回收挂关系。
+ 进程终止
  1. 关闭所有文件描述符
  2. 释放用户空间分配的内存。
   3. 进程的 pcb 残留在内核中。保存当前进程结束的状态（正常：退出值。异常。异常：终止其运行的信号编号）

## 孤儿进程

父进程先于子进程终止，子进程沦为”孤儿进程“。会被 init 进程领养。

## 僵尸进程

子进程终止，父进程未终止也未回收子进程。

## wait 回收

只有父子进程之间存在回收关系，爷孙，叔侄进程不存在回收关系。

```c
#include <sys/wait.h>

pid_t wait(int *wstatus);
参：
    传出参数：回收进程的状态。
返回值；
    成功：回收进程pid
    失败：-1，erron
```

+ 函数的作用：
  1. 阻塞等待子进程退出（终止）。
  2. 回收子进程残留在内核的 pcb。
  3. 获取子进程的退出状态（正常、异常）。——传出参数：wstatus
+ 回收子进程退出状态：
	+ 正常退出：
		+ 判断 WIFEXITED(status) 为真。
		+ 进一步是使用 WEXITSTATUS(status) 获取退出值。
	+ 异常退出：
		+ 判断 WIFSIGNAL(status) 为真。
		+ 进一步使用 WTERMSIG(status) 获取杀死子进程的信号的编号。

## waitpid

```c
pid_t waitpid(pid_t pid, int *wstatus, int options);
参数：
    pid：
    	> 0:通过 pid 指定回收某一个子进程。
		-1：回收任意子进程。
		0：回收与父进程属于同一进程组的子进程。
    wstatus：传出参数，回收子进程状态。
    options：WNOHANG —— 指定回收方式为”非阻塞“。
返回值：
    > 0 :成功,回收的进程 pid
    0：函数调用时参 3 指定了 WNOHANG，而子进程没有结束。
    失败：-1，errno
```

### 总结：

一次 wait、waitpid 调用，只能回收一个子进程！！！

想回收 N 个子进程，需要将 wait、waitpid 调用放于循环中。
