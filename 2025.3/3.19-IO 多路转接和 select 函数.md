# IO 多路转接

```c
// 为什么要写多进程 / 多线程并发程序?
在进行套接字通信的时候有一些阻塞函数: accept(), read()/recv(), write()/send()
	- 需要不停的检测新的客户端连接: 需要不停的调用 accept(), 需要独占一格线程 / 进程检测
    - 和客户端的连接建立成功, 通信
        - 发送数据: write(), 如果缓冲区被写满, 阻塞 -> 需要一个单独的线程/进程处理
        - 接收数据: read()/recv, 对方不给当前中终端发送数据, 当前终端阻塞 -> 需要单独线程处理数据接收
            
总结: 套接字通信过程中有大量的阻塞操作, 需要多个线程 / 进程处理阻塞任务
    
// 细节分析
1. accept 为什么会阻塞:
	使用了 accept 读了用于监听的文件描述符的读缓冲区, 检测过程是阻塞的
2. read/recv 为什么会阻塞:
	使用了 read/recv 检测了用于通信的文件描述符的读缓冲区, 检测过程是阻塞的
2. write/send 为什么会阻塞:
	使用了 write/send 检测了用于通信的文件描述符的写缓冲区, 如果写满会一直阻塞
        
// 结论:
使用多线程 / 多进程处理并发本质是使用不同的线程 / 江金城检测文件描述符的缓冲区
    - 文件描述符
        - 通信的
        - 监听的
    - 缓冲区
        - 读缓冲区
        - 写缓冲区
        
IO 多路转接就是调用一个喜用函数委托内核帮助我们去检测一些文件描述符的状态内核检测完毕以后, 会给用户一个反馈, 用户通过内核的反馈就指定纳西文件描述符有状态变化, 有针对的对这些文件描述符进行状态处理
        1. 内核检测到有新连接, 有新连接, 调用 accept() 函数
        这个时候调用这个函数就不阻塞了
        2. 内核检测到通信的文件描述符的读缓冲区有数据 ==> 对端给当前终端发数据
        需要使用 read()/recv() 接收数据 ==> 不阻塞
        3. 内核检测到通信的文件描述符写缓冲区可以写
        可以是以哦那个 write()/send() 发送数据 ==> 不阻塞	 
```



# select()

```cpp
// select 是如何实现 IO 转接的?
1. select 是一个跨平台的函数, Linux 和 windows 都可是使用
2. 我们调用这个函数, 该函数会调用相对应的平台的系统 api, 委托操作系统执行某些操作
3. 在调用 select 的时候需要同过参数的形式将要检测的文件描述符的集合传递给内核
    内核根据这个集合对文件描述符的状态进行检测
    	- 读集合: 需要检测这一系列文件描述符的读缓冲区(有若干个文件描述符 = 监听的 + 通信的)
           	- 监听的文件描述符, 看看有没有新的客户端连接
            - 通信的文件描述符, 看看有没有通信数据到达
        - 写集合: 委托内核检测集合中的文件描述符对应的写缓冲区是否可写
            - 通信的文件描述符, 看看有没有空间可以写数据
        - 异常的集合: 检测晚间描述符读写操作过程中是否有异常
4. 内核根据传递的集合中的数据, 对文件描述符表进行线性检测, 如果有满足条件的文件描述符, 内核会通知调用者
        - 满足条件?
			- 对于读集合: 文件描述符对应的读缓冲区中有数据
            - 对于写集合: 文件描述符的写缓冲区可写
            - 对于异常集合:
		- 内核如何通知调用者:
			- 内核会将用户传递给内核的读 / 写 / 异常集合进行修改, 得到新的数据
5. 用户得到的信息?
    1. 知道了有多少个文件描述符发生了变化
    2. 通过传出的集合可以判断是哪个发生了状态变化
```

```cpp
#include <sys/select.h>

int select(int nfds, fd_set *readfds, fd_set *writefds,
          fd_set *exceptfds, struct timeval *timeout);
参数：
	- nfds: 最大的文件描述符 + 1
        - 内核遍历的文件描述符是线性遍历的, nfds 是遍历结束的标志
	- readfds: 读集合, 存储若干个文件描述符, 并且都是检测他们的读缓冲区
        - 常用
        - 两种情况:
			- 判断有没有新连接
            - 判断有没有通信数据
        - 传入传出参数
            - 传入是委托内核检测的文件描述符的集合
            - 传出的是内核检测到的发送满足条件的文件描述符
                - 传出的文件描述符的个数 <= 传入的文件描述符的个数
    - writefds: 写集合, 存储若干个文件描述符, 并且都是检测他们的写缓冲区是否可写
		- 一般情况下, 文件描述符的写缓冲区都是可写的(有存储空间), 因此这集合很少用
    - exceptfds: 异常的集合, 检测是否有读写错误
        - 一般情况下这个集合也很少使用
        - 不检测指定为 NULL
	- timeout: 表示一个时间段
        - select 函数检测文件描述符集合需要时间, 默认如果没有满足条件的文件描述符函数会阻塞
        	- 参数如果制定了一个时间段, 且没有检测到没有满足条件的文件描述符, 超过这个时间函数会被动接触阻塞
        	- NULL, 没有发现集合中满足条件的则一直阻塞
        	- 0, 遍历完马上返回
返回值:
	> 0: 检测完之后, 满足条件的文件描述符的总个数(三个集合的和)
	= 0: 没有检测到满足条件的文件描述符, 超时时间到了, 强制函数返回
	-1: 函数调用失败了
```

```cpp
// fd_set 类型数据操作函数
// 将文件描述符 fd 从 set 中删除
void FD_CLR(int fd, fd_set *set);
// 判断文件描述符 fd 是否在 set 集合中, 如果在返回 1, 如果不在返回 0
int  FD_ISSET(int fd, fd_set *set);
// 添加
void FD_SET(int fd, fd_set *set);
// 清空操作
void FD_ZERO(fd_set *set);
```

```cpp
fd_set 数据类型和文件描述符表的关系:
	- 所有文件描述符都存储在文件描述符表中 -> 内核中
        - 默认大小: 1024个整数, 数组下表 0 - 1023
    - fd_set 记录者要委托内核检测哪一个文件描述符?
        - 如何记录的?
        	sizeof fd_set = 128byte * 8 = 1024bit
            地地址位 -> 高地址位: 0 - 1023
        - 结论:
			fd_set 中的每一个标志位和文件描述符表中的元素下标一一对应
```

```cpp
// 伪代码
int main()
{
    // 1. 创建监听的套接字
    int lfd = socket();
    // 2. 绑定
    bind();
    // 3. 设置监听
    listen();
    // 调用 IO 转接函数
	// 4. 初始化要检测的文件描述符集合
    fd_set reads, tmp;
    FD_ZERO(&reads); // 清零
    FD_SET(lfd, &reads); // 将 lfd 添加到待检测的读集合中
    // 5. 使用 select() 函数检测文件描述符的状态
    // 如果要知道文件描述符持续的状态变化, 就需要不停地检测
    int nfds = lfd;
    while (1)
    {
        // 不停地委托内核检测文件描述符的集合
        // tmp 传入的时候代表委托内核检测的读集合
        // 传出读缓冲区中有数据的集合
        tmp = reads;
        int num = select(nfds + 1, &tmp, NULL, NULL, NULL);
        // 遍历文件描述符表(相当于), i 表示文件描述符表里每个元素的值
        for (int i = lfd; i <= nfds; ++1)
        {
            // 有没有新连接
            if (FD_ISSET(lfd, &tmp))
            {
                // 建立新连接, 得到通信的 cfd
                int cfd = accept(lfd, NULL, NULL);
                // 把 cfd 添加到检测的读集合中, 下次调用 select 的时候就可以检测到了
                FD_SET(cfd, &reads);
                nfds = max(nfds, cfd);
            }
            // 有没有通信数据
            else
            {
                // 除了 lfd, 其余的文件描述符都是通信的
                if (FD_ISSET(i,&reads))
                {
                    int len = read(i, buf, sizeof buf);
                    if (len == 0)
                    {
                        // 客户端已经断开连接
                        // 通信文件描述符从检测的集合中删除
                        FD_CLR(i,&reads);
                        close(i);
                    }
                }
            }
        }
    }
    
    
    
    // 4. 等待并接受客户端连接
    
    return 0;
}
```

