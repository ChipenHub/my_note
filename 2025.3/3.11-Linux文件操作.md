# Linux 文件操作

## 文件 io
### man 手册
1. 可执行程序、shell命令。
2. 系统调用函数（内核提供的函数）。
3. 库函数
4. ……
5. 查看特殊文件格式规范。
6. ……
## 系统调用
+ 本质：内核提供给外部访问 Linux 操作的函数。
## 操作函数
### 打开文件
```c
#include <unistd.h>
#include <fcntrl.h>
int open(const char *pathname, int flag);
	参 1：打开的文件路径名（绝对、相对）。
	参 2：打开文件的方式：
	O_RDONLY|O_WONly|O_RDWR —— <fcntrl.h>
返回值：
	成功：返回个新的文件描述符。
	失败：返回-1，errno
```

```c
int open(const char *pathname, int flags, mode_t mode);
参 1：打开的文件路径名（绝对、相对）。
参 2：打开文件的方式：
参 3：使用的前提是参 2 指定了 O_CREAT。
```



## 关闭文件

```c
#include <unistd.h>

int close(int fd);
参数：
    open 返回值。
返回值：
	成功：0
	失败：-1，errno
```

## 文件创建权限
+ Linux 系统中，创建文件的权限，受 umask 文件权限屏蔽码影响。
+ 使用 open 创建文件的最终权限，受 mode 和umask 共同影响

## 文件读写
### 读文件
```c
#include <unistd.h>
	——按字节读取数据
ssize_t read(int fd, void *buf, size_t count);
参数：
	fd：打开的文件描述符 —— open（）返回值
	buf：存储读到数据的缓冲区
	count：缓冲区大小
返回值：
    成功：
		没读到文件末尾：> 0（实际读取到的字节数）
    	读到文件末尾：= 0
    失败：
    	-1:
            errno = EAGAIN：以非阻塞读文件，没读到数据。
            error ！= EAFGAIN：错误。
```

### 写文件

```cpp
#include <unistd.h>
	——按字节写出数据
ssize_t write(int fd, const void *buf, size_t count);
参数：
	fd：打开的文件描述符 —— open（）返回值
	buf：用来存储写出数据的缓冲区
	count：数据大小
返回值：
    成功：
		写出的字节个数。
    失败：
    	-1，errno
```

### 错误处理

+ sterror 函数

  ```c
  #include <string.h>
  
  char *sterror(int errnum);
  参数：错误号，当前程序的唯一全局变量。
  返回值：错误号对应的错误描述。
  ```

+ perror 函数

  ```c
  #include <stdio.h>
  
  void perror(const char *s);
  参数：用户自定义的信息，会自动与 errno 对应错误描述拼接。
  ```
## 文件描述符
+ pcb 进程控制块
   + 本质：结构体
   + 成员之一：文件描述符表
   + 文件描述符：1/2/3/4/……/1023
   + 文件描述符表使用规则：使用表中未被占用的最小文件描述符。
+ 三个特殊文件：进程启动时由系统自动打开，进程结束时系统自动关闭。
   + stdin：标准输入，0 -STDIN_FILENO
   + stdin：标准输出，1 - STDOUT_FILENO
   + stderr：标准错误，2 - STDERR_FILENO

查看：`ulimit -a`
`open files (-n)    1024`


## 阻塞和非阻塞
+ 阻塞和非阻塞是设备文件、网络文件的属性。（不是 read 和 write 的属性）
+ 产生阻塞的场景：
   + 读设备文件。
   + 读网络文件。
   ——读常规文件无“阻塞”概念。
+ /dev/tty —— 终端文件。
   + 设置 /dev/tty 文件，为非阻塞状态。——重新打开，指定 O_NONBOLOCK 属性。
```c
int fd = open("/dev/tty", O_RDWR|O_NONBLOCK);
```
## fcntl函数
+ 作用：不重新打开文件，修改文件的访问权限。
+ 函数原型：
```c
#include <fctl.h>

int fcntl(int fd, int cmd, ...);

获取文件权限：F_GETFL
设置文件权限：F_SETFL

// 获取文件权限，保存在 flag 中。
itn flg = fcntl(fd, F_GETFL);
// 修改文件权限
flg |= O_NONBLOCK // 添加非阻塞权限
fcntl(fd, F_SETFL, flg)
```
## lseek
```c
off_t lseek(int fd, off_t offset, int whence);
参数：
	fd：文件描述符
	offset：偏移量。正数向后，负数向前。
	whence：起始偏移位置。SEEK_SET/SEEK_CUR/SEEK_END
返回：
	成功：较起始位置的偏移
	失败：-1， errno
```
+ 相关知识：
	1. 文件的读和写，使用同一偏移位置。
	2. 可以使用 lseek 获取文件大小。
	3. 可以使用 lseek 拓展文件的大小。要想使文件大小真正发生拓展，必须要引起 IO 操作。
		+ 直接拓展文件，也可以使用 truncate() 函数来完成。 
## 传入参数传出参数
### 传入参数
1. 指针做函数参数。
2. 通常有 const 关键字修饰。
3. 指针指向有效区域，在函数内部做读操作。
### 传出参数
1. 指针做函数参数
2. 在函数调用之前，指针指向的空间可以无意义，但必须有效
3. 在函数内部，做写操作
4. 函数调用结束后，充当函数返回值
### 传入传出操作
1. 指针做函数参数
2. 在函数调用之前，指针指向的空间有效且有实际意义
3. 在函数内部，先做读操作，后做写操作
4. 函数调用结束后，充当函数返回值

## Link 和 unlink 函数
```c
int link(const char *oldpath, const char *newpath);
int unlink(const char *pathname);
```
**unlink 特性**：

+ 调用 unlink 只是让文件具备了被释放的条件。不一定立即释放。
+ 硬链接计数为 0 的文件不会被马上释放。要等到所有打开该文件的进程运行结束且没有任何进程使用该文件，此时，系统择机释放该文件。
隐式回收：
+ 程序运行结束，打开的文件、申请的内存空间，会被系统自动释放。——隐式回收系统资源。

## 目录操作

### 操作函数

1. 打开目录 opendir
2. 关闭目录 closedir
3. 读取目录项 readdir