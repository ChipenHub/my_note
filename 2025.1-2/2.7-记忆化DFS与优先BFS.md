# 记忆化DFS以及基于优先级队列的BFS

## 记忆化DFS

### 例一 斐波那契数列

1. 递归写法

```cpp
int dfs(int n) {
	if(n == 1 || n == 2) return 1;
	return dfs(n - 1) + dfs(n - 2);
}
```

2. 记忆化DFS

```cpp
int dfs(int n) {
    // 如果有，直接返回。
    if(fib[n]) return fib[n];
    // 如果没有，保存后再返回。
    if(n == 1 || n == 2) return 1;
    fib[n] = dfs(n - 1) + dfs(n - 2);
    return fib[n];
}
```

### 例二 01背包问题

1. 递归写法

```cpp
int dfs(int i, int v) {
	if(i == 0 || v <= 0) return 0;
	if(w[i] > v) return dfs(i - 1, v);
	else if(w[i] <= v) return max(dfs(i - 1, v), dfs(i - 1, v - w[i]) + p[i]);
}
```

2. 记忆化DFS

```cpp
int dfs(int i, int v) {
    // 如果保存了，直接返回
    if(dp[i][v]) return dp[i][v];
    
	if(i == 0 || v <= 0) return 0;
    // 如果没有，保存后再返回。
	if(w[i] > v) dp[i][v] = dfs(i - 1, v);
	else if(w[i] <= v) dp[i][v] = max(dfs(i - 1, v), dfs(i - 1, v - w[i]) + p[i]);
    return dp[i][v];
}
```

### 例 3 老鼠和奶酪

- 题目描述
  - 老鼠在某个城市储存了一些奶酪，城市可以看成一个 $n*n$ 的网格，在每个网格的洞里，老鼠存储了 $[0,100]$ 块的奶酪。现在，它准备享用这些美味。开始，它在$(0,0)$的位置，每吃光一个地方的奶酪，就转移到边上水平或者垂直的位置。麻烦的是，有只猫在洞的附近，所以它每次在被猫抓住之前最多只能移动 $k$个位置，更糟糕的是，每吃掉一个地方的奶酪，就会变胖。所以，为了下一次逃跑有足够的能量，每次它必须移动到一个比这次有更多奶酪的网格。
  - 给定$n$和$k$以及每个网格的奶酪数量；
  - 请计算：老鼠最多能吃到多少块奶酪（直到不能继续活动）？

答案代码

```cpp
int dfs(int x, int y) // 表示从(x, y)出发能得到的最优解	
{
    int answer = 0;
    if (ans[x][y]) return ans[x][y];
    for (int i = 0; i < 4; i++)
        for (int j = 1; j <= k; j++) {
            int xx = x + direction[i][0] * j;
            int yy = y + direction[i][1] * j;
            if (check_range(xx, yy) && init[xx][yy] > init[x][y])
                answer = max(answer, dfs(xx, yy));
        }
    ans[x][y] = answer + init_chese[x][y];
    return ans[x][y];
}
```

### 例 4 How many ways

- 题目描述

- 你控制一个机器人从一个棋盘的起始点 $(1,1) $走到棋盘的终点$ (n,m)$。游戏的规则描述如下：
  1. 机器人一开始在棋盘的起始点并有起始点所标有的能量。
  2. 机器人只能向右或者向下走，并且每走一步消耗一单位能量。
  3. 机器人不能在原地停留。
  4. 当机器人选择了一条可行路径后，当他走到这条路径的终点时，他将只有终点所标记的能量。
- 一共有多少种方案数？

## 基于优先队列的BFS