# 2.4-STL库中stack和queue的模拟实现

## stack

实现了stack的几个核心接口，由于stl中stack和queue为容器，所以相比于以前的类，这两个容器实现起来比较轻松。

```cpp
#pragma once
#include <iostream>
#include <vector>

namespace st {
    template<class T, class Container>
    class my_stack {
    public:
        void push(const T& x) {
            _con.push_back(x);
        }

        void pop() {
            _con.pop_back();
        }

        const T& top() const {
            return _con.back();
        }

        size_t size() const {
            return _con.size();
        }

        bool empty() const {
            return _con.empty();
        }

    private:
        Container _con;
    };

	// 测试用例。
    void test_stack() {
        my_stack<int, std::vector<int>> st;
        st.push(1);
        st.push(2);
        st.push(3);
        st.push(4);
        st.push(5);
        st.push(6);

        while(!st.empty()) {
            std::cout << st.top() << " ";
            st.pop(); // 6 5 4 3 2 1 
        }
        std::cout<< std::endl;

    }
}
```

## queue

```cpp
#pragma once
#include <iostream>
#include <vector>
#include <list>

namespace st {
    template<class T, class Container = std::list<T>>
    class my_queue {
    public:
        void push(const T& x) {
            _con.push_back(x);
        }

        void pop() {
            _con.pop_front();
        }

        const T& front() const {
            return _con.front();
        }
        
        const T& back() const {
            return _con.back();
        }

        size_t size() const {
            return _con.size();
        }

        bool empty() const {
            return _con.empty();
        }

    private:
        Container _con;
    };

	// 测试用例。
    void test_queue() {
        my_queue<int> q;
        q.push(1);
        q.push(2);
        q.push(3);
        q.push(4);
        q.push(5);
        q.push(6);

        while(!q.empty()) {
            std::cout << q.front() << " ";
            q.pop();
        }
        std::cout<< std::endl; // 1 2 3 4 5 6 

    }
}
```

