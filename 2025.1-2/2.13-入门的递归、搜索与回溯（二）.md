# 2.13-入门的递归、搜索与回溯（二）

本文接续上一篇，同时补充一点题目总结。

#### 递归、搜索与回溯问题总结

##### 1. 全排列（排列问题）

**全排列**中每个元素都有可能成为排列的**第一位**，在递归的遍历中，每一次遍历都要从头开始遍历，为了防止重复，往往会创建一个`check[]`**全局变量**以存储排列过的元素，以实现递归搜索的**剪枝**。

##### 2. 子集（解法二）、括号生成、字母大小写全排列，电话号号码的字母组合（组合问题）

在**子集**问题中，每次递归一定**只有部分元素**可以在当前位置插入，相比于全排列中的`if`剪枝也具有的这种性质，子集问题的约束往往与`pos`变量具有**关联性**，因此函数中往往加入`pos`类参量，做到如在迭代时**直接**从`pos`开始进行等**“具有剪枝性质”**的操作。也就是说排列问题和组合问题在忽略剪枝条件的情况下具有**相同的性质**。

##### 3. 优美的排列（排列问题 + 组合问题）

正如在组合问题中所说，在排列问题中添加一个有关于`pos`的**剪枝约束**，就实现了二者的融合。

##### 4. N皇后

N皇后问题的解答实现了基于数学的**剪枝**操作，本质和**优美的排列**没有区别。

##### 5. 解数独

解数独问题不但具有其独特且复杂的约束条件，并且融合了**优美的排列**的做法。由于问题**一定只有一个解**，因此考虑到了**借助返回值来判断本次遍历是否有解**，在**无解的情况下**再尝试回溯。



#### [526. 优美的排列](https://leetcode.cn/problems/beautiful-arrangement)

**分析**：本文接续上次写的。

```cpp
class Solution {
public:
    int ret;
    bool check[15];
    int countArrangement(int n) {
        dfs(1, n);
        return ret;
    }

    void dfs(int pos, int n) {
        if (pos == n + 1) {
            ret++;
            return;
        }
        for (int i = 1; i < n + 1; i++) {
            if (check[i] == false && (pos % i == 0 || i % pos == 0)) {
                check[i] = true;
                dfs(pos + 1, n);
                check[i] = false;
            }
        }
    }
};
```



#### [51. N 皇后](https://leetcode.cn/problems/n-queens)

**分析**：破我防是吧？我就不认输，学不会我非学我就学，我就不认输。

```cpp
class Solution {
public:
    bool checkCol[10], checkDig1[20], checkDig2[20];
    vector<vector<string>> ret;
    vector<string> path;
    int n;
    vector<vector<string>> solveNQueens(int _n) {
        n = _n;
        path.resize(n);
        for (int i = 0; i < n; i++) {
            path[i].append(n, '.');
        }
        dfs(0);
        return ret;
    }

    void dfs(int row) {
        if (row == n) {
            ret.push_back(path);
            return;
        }

        for (int col = 0; col < n; col++) {
            if (!checkCol[col] && !checkDig1[row - col + n] && !checkDig2[row + col]) {
                path[row][col] = 'Q';
                checkCol[col] = checkDig1[row - col + n] = checkDig2[row + col] = true;
                dfs(row + 1);
                path[row][col] = '.';
                checkCol[col] = checkDig1[row - col + n] = checkDig2[row + col] = false;
            }
        }
    }
};
```



#### [36. 有效的数独](https://leetcode.cn/problems/valid-sudoku)

**分析**：本题的存在是为下一题解数独做铺垫。

```cpp
class Solution {
public:
    bool row[9][10];
    bool col[9][10];
    bool grid[3][3][10];
    bool isValidSudoku(vector<vector<char>>& board) {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    int num = board[i][j] - '0';
                    if (row[i][num] || col[j][num] || grid[i / 3][j / 3][num]) return false;
                    row[i][num] = col[j][num] = grid[i / 3][j / 3][num] = true;
                }
            }
        }
        return true;
    }
};
```



#### [37. 解数独](https://leetcode.cn/problems/sudoku-solver)

**分析**：可以借助上一题的铺垫更好的解决。

```cpp
class Solution {
public:
    bool col[9][10], row[9][10], grid[3][3][10];

    void solveSudoku(vector<vector<char>>& board) {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    int num = board[i][j] - '0';
                    row[i][num] = col[j][num] = grid[i / 3][j / 3][num] = true;
                }
            }
        }
        dfs(board);
    }

    bool dfs(vector<vector<char>>& board) {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') {
                    for (int num = 1; num <= 9; num++) {
                        if (!row[i][num] && !col[j][num] &&
                            !grid[i / 3][j / 3][num]) {
                            board[i][j] = '0' + num;
                            row[i][num] = col[j][num] =
                                grid[i / 3][j / 3][num] = true;
                            if (dfs(board))
                                return true; // 第一次返回，验证本次填写是否正确，如果错误就回溯。
                            board[i][j] = '.';
                            row[i][num] = col[j][num] =
                                grid[i / 3][j / 3][num] = false;
                        }
                    }
                    return false; // 如果所有数字均无法填入，返回false。
                }
            }
        }
        return true; // 如果找不到'.'，返回true。
    }
};
```



#### [79. 单词搜索](https://leetcode.cn/problems/word-search)

**分析**：很快啊，我啪的一下就写出了下面这串代码：

```cpp
class Solution {
public:
    string word;
    bool exist(vector<vector<char>>& board, string _word) {
        word = _word;
        return dfs(board, 0);
    }

    bool dfs(vector<vector<char>>& board, int pos) {
        if (pos == word.size())
            return true;
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[0].size(); j++) {
                if ((pos == 0 && board[i][j] == word[pos]) ||
                    (i > 0 && board[i - 1][j] == word[pos - 1] &&
                     board[i][j] == word[pos]) ||
                    (i < board.size() - 1 && board[i + 1][j] == word[pos - 1] &&
                     board[i][j] == word[pos]) ||
                    (j > 0 && board[i][j - 1] == word[pos - 1] &&
                     board[i][j] == word[pos]) ||
                    (j < board[0].size() - 1 &&
                     board[i][j + 1] == word[pos - 1] &&
                     board[i][j] == word[pos])) {
                    char tmp = board[i][j];
                    board[i][j] = '.';
                    if (dfs(board, pos + 1)) return true;
                    board[i][j] = tmp;
                }
            }
        }
        return false;
    }
};
```

**分析**：很不幸，上面的代码报错了。问题有二：在每次遍历中都是从第一个格开始遍历，速度极慢，而且并不能准确找到当前位置的前一个位置。下面是正确的解答。

```cpp
class Solution {
public:
    string word;
    vector<vector<char>> board;

    bool exist(vector<vector<char>>& _board, string _word) {
        word = _word;
        board = _board;
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[0].size(); j++) {
                if (dfs(i, j, 0))
                    return true;
            }
        }

        return false;
    }
    
    bool dfs(int row, int col, int pos) {
        if (pos == word.size()) return true;
        if (row >= board.size() || col >= board[0].size())
            return false;
        if (board[row][col] == word[pos]) {
            int tmp = board[row][col];
            board[row][col] = '.';
            if (dfs(row, col + 1, pos + 1) || dfs(row + 1, col, pos + 1) ||
                dfs(row - 1, col, pos + 1) || dfs(row, col - 1, pos + 1))
                return true;
            board[row][col] = tmp; // 回溯。
        }
        return false;
    }
};
```



#### [1219. 黄金矿工](https://leetcode.cn/problems/path-with-maximum-gold)

**分析**：有了上次的经验，这次就轻松多了。

```cpp
class Solution {
public:
    int path = 0, ret = 0;
    vector<vector<int>> grid;
    int getMaximumGold(vector<vector<int>>& _grid) {
        grid = _grid;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                dfs(i, j);
            }
        }

        return ret;
    }

    void dfs(int i, int j) {
        if (i >= grid.size() || i < 0 || j >= grid[0].size() || j < 0 ||
            grid[i][j] == 0) {
            ret = max(path, ret);
            return;
        }
        int tmp = grid[i][j];
        path += grid[i][j];
        grid[i][j] = 0;
        dfs(i, j + 1);
        dfs(i + 1, j);
        dfs(i, j - 1);
        dfs(i - 1, j);
        grid[i][j] = tmp;
        path -= grid[i][j];
    }
};
```



#### [980. 不同路径 III](https://leetcode.cn/problems/unique-paths-iii)

```cpp
#include <vector>

class Solution {
public:
    vector<vector<int>> grid;
    int ret = 0;

    int uniquePathsIII(vector<vector<int>>& _grid) {
        grid = _grid;
        int remain = 0, si, sj;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == 1) {
                    si = i;
                    sj = j;
                    remain++;
                } else if (grid[i][j] == 0 || grid[i][j] == 2) {
                    remain++;
                }
            }
        }
        dfs(si, sj, remain);
        return ret;
    }
    void dfs(int i, int j, int remain) {
        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())
            return;
        int cell = grid[i][j];
        if (cell == -1)
            return;
        if (cell == 2) {
            if (remain == 1)
                ret++;
            return;
        }
        grid[i][j] = -1;
        remain--;
        dfs(i - 1, j, remain);
        dfs(i + 1, j, remain);
        dfs(i, j - 1, remain);
        dfs(i, j + 1, remain);
        grid[i][j] = cell;
    }
};
```



#### [733. 图像渲染](https://leetcode.cn/problems/flood-fill)

**分析**：本题及以下使用的算法名为Floodfill。

```cpp
class Solution {
public:
    int prev, dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0};
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        prev = image[sr][sc];
        if (image[sr][sc] == color) return image;
        dfs(image, sr, sc, color);
        return image;
    }

    void dfs(vector<vector<int>>& image, int i, int j, int color) {
        image[i][j] = color;
        for (int k = 0; k < 4; k++) {
            int x = i + dx[k], y = j + dy[k];
            if (x >= 0 && x < image.size() && y >= 0 && y < image[0].size()
            && image[x][y] == prev) {
                dfs(image, x, y, color);
            }
        }
    }
};
```



#### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands)

**分析**：本题和上一题区别不大。

```cpp
class Solution {
public:
    int m, n, dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0};
    int numIslands(vector<vector<char>>& grid) {
        m = grid.size(), n = grid[0].size();
        int ret = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    ++ret;
                }
            }
        }

        return ret;
    }

    void dfs(vector<vector<char>>& grid, int i, int j) {
        grid[i][j] = '0';

        for (int k = 0; k < 4; k++) {
            int x = i + dx[k], y = j + dy[k];
            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == '1') {
                dfs(grid, x, y);
            }
        }
    }
};
```



#### [LCR 105. 岛屿的最大面积](https://leetcode.cn/problems/ZL6zAn)

**分析**：本题也和前面没啥区别。

```cpp
class Solution {
public:
    int m, n, ret, count, dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0}, vis[51][51];
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        m = grid.size(), n = grid[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (!vis[i][j] && grid[i][j] == 1) {
                    count = 0;
                    dfs(grid, i, j);
                    ret = max(ret, count);
                }
            }
        }

        return ret;
    }

    void dfs(vector<vector<int>>& grid, int i, int j) {
        ++count;
        vis[i][j] = true;
        for (int k = 0; k < 4; k++) {
            int x = i + dx[k], y = j + dy[k];
            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 1 &&
                vis[x][y] == false) {
                    dfs(grid, x, y);
                }
        }
    }
};
```



#### [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions)

**分析**：正难则反，先处理出边界的情况，然后再进行取反。

```cpp
class Solution {
public:
    int dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0}, m, n;
    void solve(vector<vector<char>>& board) {
        m = board.size(), n = board[0].size();
        // 正难则反，先处理边界。
        for (int j = 0; j < n; j++) {
            if (board[0][j] == 'O')
                dfs(board, 0, j);
            if (board[m - 1][j] == 'O')
                dfs(board, m - 1, j);
        }
        for (int i = 0; i < m; i++) {
            if (board[i][0] == 'O')
                dfs(board, i, 0);
            if (board[i][n - 1] == 'O')
                dfs(board, i, n - 1);
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == '.')
                    board[i][j] = 'O';
                else if (board[i][j] == 'O')
                    board[i][j] = 'X';
            }
        }
    }

    void dfs(vector<vector<char>>& board, int i, int j) {
        board[i][j] = '.';
        for (int k = 0; k < 4; k++) {
            int x = i + dx[k], y = j + dy[k];
            if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] == 'O') {
                dfs(board, x, y);
            }
        }
    }
};
```



#### [417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow)

**分析**：逆流思考。

```cpp
#include <vector>

class Solution {
public:
    int m, n, dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0};
    bool pac[200][200], atl[200][200];

    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        m = heights.size();
        if (m == 0) return {};
        n = heights[0].size();
        for (int i = 0; i < m; i++) dfs(heights, i, 0, pac);
        for (int j = 0; j < n; j++) dfs(heights, 0, j, pac);
        for (int i = 0; i < m; i++) dfs(heights, i, n - 1, atl);
        for (int j = 0; j < n; j++) dfs(heights, m - 1, j, atl);

        vector<vector<int>> ret;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (pac[i][j] && atl[i][j]) {
                    ret.push_back({i, j});
                }
            }
        }
        return ret;
    }

    void dfs(vector<vector<int>>& heights, int i, int j, bool vis[][200]) {
        vis[i][j] = true;
        for (int k = 0; k < 4; k++) {
            int x = i + dx[k], y = j + dy[k];
            if (x >= 0 && x < m && y >= 0 && y < n && !vis[x][y] && heights[x][y] >= heights[i][j]) {
                dfs(heights, x, y, vis);
            }
        }
    }
};
```



#### [529. 扫雷游戏](https://leetcode.cn/problems/minesweeper)

**分析**：掌握前面的，这个并不难。

```cpp
class Solution {
public:
    int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
    int dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};
    int m, n;
    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
        m = board.size(), n = board[0].size();
        int x = click[0], y = click[1];
        if (board[x][y] == 'M') {
            board[x][y] = 'X';
            return board;
        }
        dfs(board, x, y);
        return board;
    }
    void dfs(vector<vector<char>>& board, int i, int j) {
        int count = 0;
        for (int k = 0; k < 8; k++) {
            int x = i + dx[k], y = j + dy[k];
            if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] == 'M') {
                ++count;
            }
        }
        if (count) {
            board[i][j] = '0' + count;
        } else {
            board[i][j] = 'B';
            for (int k = 0; k < 8; k++) {
            int x = i + dx[k], y = j + dy[k];
            if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] == 'E') {
                dfs(board, x, y);
            }
        }
    }
    }
};
```