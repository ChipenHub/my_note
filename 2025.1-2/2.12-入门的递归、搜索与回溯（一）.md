# 2.12-入门的递归、搜索与回溯（一）

## 递归与DFS深度优先搜索

### 递归 (Recursion)

#### 定义
递归是**函数直接或间接调用自身**的编程技巧。递归三要素：
1. 终止条件 (Base Case)
2. 递归调用 (Recursive Call)
3. 缩小问题规模 (Progress)

#### 特点
```cpp
int factorial(int n) {
    if(n == 0) return 1;          // 终止条件
    return n * factorial(n-1);    // 递归调用
}
```

- 代码简洁优雅，描述自相似问题
- 存在栈溢出风险（深度过大时）
- 适用场景：树形结构、分治算法、回溯等

---

### 深度优先搜索 (DFS)

#### 定义
一种**优先探索最深路径**的图遍历算法，常用递归/栈实现。核心思想：
1. 访问顶点
2. 递归访问其未被访问的邻接点
3. 回溯到前驱节点

#### 递归实现示例
```cpp
void dfs(TreeNode* root) {
    if(!root) return;             // 终止条件
    
    visit(root);                  // 访问当前节点
    dfs(root->left);              // 递归左子树
    dfs(root->right);             // 递归右子树
}
```

### 递归与DFS的关系

| 维度       | 递归                     | DFS                          |
| ---------- | ------------------------ | ---------------------------- |
| **性质**   | 编程实现方式             | 算法思想                     |
| **实现**   | 通过函数调用栈管理状态   | 可用递归/显式栈实现          |
| **应用**   | 解决分治、树状结构等问题 | 解决路径查找、状态遍历等问题 |
| **复杂度** | 受系统栈深度限制         | 时间复杂度通常为O(V+E)       |

---

### 应用场景对比

#### 递归典型场景
- 阶乘/斐波那契数列计算
- 二叉树遍历（前序/中序/后序）
- 归并排序/快速排序

#### DFS典型场景
- 迷宫路径查找
- 图的连通分量检测
- 组合问题（如八皇后）
- 拓扑排序

---

### 使用注意事项

1. **递归深度**  
   系统栈空间有限（通常1MB），递归层数超过约1万级会导致栈溢出

2. **重复计算**  
   斐波那契数列等递归会出现重复计算，需配合备忘录优化

3. **剪枝优化**  
   DFS遍历时通过条件判断提前终止无效路径的探索

---

### 综合应用示例
```cpp
// 二叉树路径总和（DFS递归实现）
bool hasPathSum(TreeNode* root, int target) {
    if(!root) return false;
    if(!root->left && !root->right) 
        return target == root->val;
    
    return hasPathSum(root->left, target - root->val) || 
           hasPathSum(root->right, target - root->val);
}
```

#### [面试题 08.06. 汉诺塔问题](https://leetcode.cn/problems/hanota-lcci/)

**分析**：经典的递归问题。

```cpp
class Solution {
public:

    void dfs(vector<int>& A, vector<int>& B, vector<int>& C, int n) {
        if (n == 1) {
            C.push_back(A.back());
            A.pop_back();
            return;
        }
        dfs(A, C, B, n - 1);
        C.push_back(A.back());
        A.pop_back();
        dfs(B, A, C, n - 1);
    }
    void hanota(vector<int>& A, vector<int>& B, vector<int>& C) {
        dfs(A, B, C, A.size());
    }
};
```



#### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (list1 == nullptr) return  list2;
        if (list2 == nullptr) return  list1;
        if (list1->val <= list2->val) {
            list1->next = mergeTwoLists(list1->next, list2);
            return list1;
        } else {
            list2->next = mergeTwoLists(list2->next, list1);
            return list2;
        }
    }
};
```



#### [LCR 024. 反转链表](https://leetcode.cn/problems/UHnkqh/)

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return head;
        ListNode* newhead = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newhead;
    }
};
```



#### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs)

**分析**：这种题犹豫一秒就算输。

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return head;
        ListNode* next = head->next;
        head->next = swapPairs(next->next);
        next->next = head;
        return next;
    }
};
```



#### [2331. 计算布尔二叉树的值](https://leetcode.cn/problems/evaluate-boolean-binary-tree)

**分析**：力扣的编译器认为如果你的`if`似乎没有涵盖所有情况且代码最后没有`return`就会报错，所以不得不改成`else`。

```cpp
class Solution {
public:
    bool evaluateTree(TreeNode* root) {
        if (root->left == nullptr) return root->val;
        else if (root->val == 2) return evaluateTree(root->left) || evaluateTree(root->right);
        else return evaluateTree(root->left) && evaluateTree(root->right);
        
    }
};
```



#### [LCR 049. 求根节点到叶节点数字之和](https://leetcode.cn/problems/3Etpl5)

```cpp
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        return dfs(root, 0);
    }

    int dfs(TreeNode* root, int presum) {
        presum = presum * 10 + root->val;
        if (root->left == nullptr && root->right == nullptr) return presum;
        int ret = 0;
        if (root->left) ret += dfs(root->left, presum);
        if (root->right) ret += dfs(root->right, presum);
        return ret;
    }
};
```



#### [LCR 047. 二叉树剪枝](https://leetcode.cn/problems/pOCWxh)

```cpp
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        root->left = pruneTree(root->left);
        root->right = pruneTree(root->right);
        if (root->val == 0 && root->left == nullptr && root->right == nullptr) {
            return nullptr;
        }
        return root;
    }
};
```



#### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree)

**分析**：这个题容易坑的是要保证当前节点的左子树的所有节点都当前节点， 右子树则大于。

```cpp
class Solution {
public:
    bool validate(TreeNode* root, long min, long max) {
        if (root == nullptr) return true;
        else if (root->val <= min || root->val >= max) return false;
        else return validate(root->left, min, root->val)
        && validate(root->right, root->val, max);
    }

    bool isValidBST(TreeNode* root) {
        return validate(root, LONG_MIN, LONG_MAX);
    }
};
```



#### [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst)

**分析**：中序遍历。

```cpp
class Solution {
public:
    int count;
    int ret;
    int kthSmallest(TreeNode* root, int k) {
        count = k;
        dfs(root);
        return ret;
    }

    void dfs(TreeNode* root) {
        if (root == nullptr || count == 0) return;
        dfs(root->left);
        count--;
        if(count == 0) ret = root->val;
        dfs(root->right);
    }
};
```



#### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths)

```cpp
class Solution {
public:
    vector<string> ret;
    void dfs(TreeNode* root, string path) {
        if (root == nullptr) return;
        path += to_string(root->val);
        if (root->left == nullptr && root->right == nullptr) {
            ret.push_back(path);
            return;
        }
        path += "->";
        dfs(root->left, path);        
        dfs(root->right, path);        
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        string path;
        dfs(root, path);
        return ret;        
    }
};
```



#### [LCR 083. 全排列](https://leetcode.cn/problems/VvJkup)

**分析**：本题在我之前的关于DFS的博客里有详细解释。

```cpp
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;
    bool check[7];
    vector<vector<int>> permute(vector<int>& nums) {
        dfs(nums);
        return ret;
    }

    void dfs(vector<int> nums) {
        if(nums.size() == path.size()) {
            ret.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (check[i] == false) {
                path.push_back(nums[i]);
                check[i] = true;
                dfs(nums);
                path.pop_back();
                check[i] = false;
            }
            
        }

    }
};
```



#### [LCR 079. 子集](https://leetcode.cn/problems/TVdhkn)

**分析**：解法一：针对每一个元素，考虑选或者不选（对标上一题）。

```cpp
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;
    vector<vector<int>> subsets(vector<int>& nums) {
        dfs(nums, 0);
        return ret;
    }
    void dfs(vector<int>& nums, int pos) {
        if (pos == nums.size()) {
            ret.push_back(path);
            return;
        }

        // 选。
        path.push_back(nums[pos]);
        dfs(nums, pos + 1);
        path.pop_back(); // 回溯。

        // 不选。
        dfs(nums, pos + 1);
    }
};
```

**分析**：解法二（更优）：直接从pos开始遍历，可以实现剪枝下顺序重复的部分。

```cpp
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;

    vector<vector<int>> subsets(vector<int>& nums) {
        dfs(nums, 0);
        return ret;
    }


    void dfs(vector<int>& nums, int pos) {
        ret.push_back(path);
        for (int i = pos; i < nums.size(); i++) {
            path.push_back(nums[i]);
            dfs(nums, i + 1);
            path.pop_back(); // 回溯。
        }
    }
};
```



#### [1863. 找出所有子集的异或总和再求和](https://leetcode.cn/problems/sum-of-all-subset-xor-totals)

**分析**：很典型也很简单的回溯，注意，此题的解法相当于上一题的解法二而不是解法一。

```cpp
class Solution {
public:
    int path, sum;
    void dfs(vector<int>& nums, int pos) {
        sum += path;
        for (int i = pos; i < nums.size(); i++) {
            path ^= nums[i];
            dfs(nums, i + 1);
            path ^= nums[i]; // 回溯。
        }
    }
    int subsetXORSum(vector<int>& nums) {
        dfs(nums, 0);
        return sum;
    }
};
```



#### [LCR 084. 全排列 II](https://leetcode.cn/problems/7p8L0Z)

**分析**：“全排列II”相比于“全排列”，`if`条件判断更复杂。

```cpp
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;
    bool check[8];

    void dfs(vector<int>& nums) {
        if (path.size() == nums.size()) {
            ret.push_back(path);
            return;
        }

        for (int i = 0; i < nums.size(); i++) {
            if (check[i] == false && (i == 0 || (nums[i - 1] != nums[i] || check[i - 1]))) {
                path.push_back(nums[i]);
                check[i] = true;
                dfs(nums);
                path.pop_back();
                check[i] = false;
            }
        }
    }

    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        dfs(nums);
        return ret;
    }
};
```



#### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number)

```cpp
class Solution {
public:
    vector<string> ret;
    string path;
    string hash[10] = {"", "", "abc", "def", "ghi","jkl", "mno", "pqrs", "tuv", "wxyz"};

    vector<string> letterCombinations(string digits) {
        if(digits.size() == 0) return ret;
        dfs(digits, 0);
        return ret;
    }

    void dfs(string digits, int pos) {
        if (path.size() == digits.size()) {
            ret.push_back(path);
            return;
        }
        for (auto ch : hash[digits[pos] - '0']) {
            path.push_back(ch);
            dfs(digits, pos + 1);
            path.pop_back();
        }
    }
};
```



#### [LCR 085. 括号生成](https://leetcode.cn/problems/IDBivT)

```cpp
class Solution {
public:
    vector<string> ret;
    string path;
    int _n, left, right;
    vector<string> generateParenthesis(int n) {
        _n = n;
        dfs();
        return ret;
    }

    void dfs() {
        if (right == _n) {
            ret.push_back(path);
            return;
        }

        if (left < _n) {
            path.push_back('(');
            left++;
            dfs();
            path.pop_back();
            left--;
        }

        if (right < left) {
            path.push_back(')');
            right++;
            dfs();
            path.pop_back();
            right--;
        }
    }
};
```



#### [LCR 080. 组合](https://leetcode.cn/problems/uUsW3B)

**分析**：还差两个。

```cpp
class Solution {
public:
    int k, n;
    vector<vector<int>> ret;
    vector<int> path;

    vector<vector<int>> combine(int _n, int _k) {
        k = _k;
        n = _n;
        dfs(1);
        return ret;
    }

    void dfs(int pos) {
        if (path.size() == k) {
            ret.push_back(path);
            return;
        }

        for (int i = pos; i <= n; i++) {
                path.push_back(i);
                dfs(i + 1);
                path.pop_back();
        }
    }
};
```



#### [LCR 081. 组合总和](https://leetcode.cn/problems/Ygoe9J)

**分析**：还差一个。

```cpp
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;
    int t, sum;
    vector<int> c;

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        c = candidates;
        t = target;
        dfs(0);
        return ret;
    }

    void dfs(int pos) {
        if (sum == t) {
            ret.push_back(path);
            return;
        } else if (sum > t || pos >= c.size()) {
            return;
        }

        for (int i = pos; i < c.size(); i++) {
            path.push_back(c[i]);
            sum += c[i];
            dfs(i);
            path.pop_back();
            sum -= c[i];
        }
    }
};
```



#### [784. 字母大小写全排列](https://leetcode.cn/problems/letter-case-permutation)

**分析**：总算写完了。

```cpp
class Solution {
public:
    vector<string> ret;
    string path;
    vector<string> letterCasePermutation(string s) {
        dfs(s, 0);
        return ret;
    }

    void dfs(string s, int pos) {
        if (path.size() == s.size()) {
            ret.push_back(path);
            return;
        }

        if (s[pos] <= '9') {
            path.push_back(s[pos]);
            dfs(s, pos + 1);
            path.pop_back();
        } else {
            // 放大写。
            path.push_back(toupper(s[pos]));
            dfs(s, pos + 1);
            path.pop_back();
            // 放小写。
            path.push_back(tolower(s[pos]));
            dfs(s, pos + 1);
            path.pop_back();
        }
    }
};
```

