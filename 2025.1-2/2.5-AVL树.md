# 2.5-AVLæ ‘

## ğŸŒ² å®šä¹‰ä¸æ€§è´¨
**AVLæ ‘**ï¼ˆAdelson-Velsky and Landis Treeï¼‰æ˜¯æœ€æ—©å‘æ˜çš„è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œé€šè¿‡ç»´æŠ¤**å¹³è¡¡å› å­**ç¡®ä¿æ ‘çš„é«˜åº¦å§‹ç»ˆä¸º `O(log N)`ã€‚å…¶æ ¸å¿ƒç‰¹æ€§ä¸ºï¼š
- **å¹³è¡¡å› å­**ï¼šä»»æ„èŠ‚ç‚¹çš„å·¦å³å­æ ‘é«˜åº¦å·®ç»å¯¹å€¼ä¸è¶…è¿‡ 1
- **æ—‹è½¬æ“ä½œ**ï¼šé€šè¿‡å››ç§æ—‹è½¬æ“ä½œï¼ˆå·¦æ—‹ã€å³æ—‹ã€å·¦å³æ—‹ã€å³å·¦æ—‹ï¼‰åŠ¨æ€è°ƒæ•´å¹³è¡¡

## âš–ï¸ å¹³è¡¡å› å­
æ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­è®¡ç®—å…¬å¼ï¼š
```cpp
å¹³è¡¡å› å­ = å³å­æ ‘é«˜åº¦ - å·¦å­æ ‘é«˜åº¦
```

å¹³è¡¡å› å­èŒƒå›´ï¼š`[-1, 0, 1]`

## ğŸ”„ æ—‹è½¬æ“ä½œç±»å‹
| æ—‹è½¬ç±»å‹ | è§¦å‘æ¡ä»¶             | ç¤ºæ„å›¾         |
| -------- | -------------------- | -------------- |
| å·¦æ—‹     | å³å­æ ‘å³èŠ‚ç‚¹å¯¼è‡´å¤±è¡¡ | â†’ å³ä¾§è¶…é‡æ‹‰å¹³ |
| å³æ—‹     | å·¦å­æ ‘å·¦èŠ‚ç‚¹å¯¼è‡´å¤±è¡¡ | â† å·¦ä¾§è¶…é‡æ‹‰å¹³ |
| å·¦å³æ—‹   | å·¦å­æ ‘å³èŠ‚ç‚¹å¯¼è‡´å¤±è¡¡ | â†™ å…ˆå·¦æ—‹å†å³æ—‹ |
| å³å·¦æ—‹   | å³å­æ ‘å·¦èŠ‚ç‚¹å¯¼è‡´å¤±è¡¡ | â†˜ å…ˆå³æ—‹å†å·¦æ—‹ |

---

## ğŸ–¥ï¸ æ ¸å¿ƒä»£ç å®ç°ï¼ˆC++ï¼‰

```cpp
#pragma once
#include <iostream>
#include <assert.h>
using namespace std;

// å®šä¹‰AVLæ ‘èŠ‚ç‚¹ç»“æ„
template<class K, class V>
struct AVLTreeNode {
    AVLTreeNode<K, V>* _left;  // å·¦å­èŠ‚ç‚¹æŒ‡é’ˆ
    AVLTreeNode<K, V>* _right; // å³å­èŠ‚ç‚¹æŒ‡é’ˆ
    AVLTreeNode<K, V>* _parent; // çˆ¶èŠ‚ç‚¹æŒ‡é’ˆ
    pair<K, V> _kv;  // é”®å€¼å¯¹
    int _bf; // balance factor å¹³è¡¡å› å­

    // æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–èŠ‚ç‚¹
    AVLTreeNode(const pair<K, V>& kv)
    : _left(nullptr), _right(nullptr), _parent(nullptr), _kv(kv), _bf(0) {}
};

// å®šä¹‰AVLæ ‘ç±»
template<class K, class V>
class AVLTree {
    typedef AVLTreeNode<K, V> Node;
public:
    // æ’å…¥é”®å€¼å¯¹
    bool Insert(const pair<K, V>& kv) {
        if(_root == nullptr) {
            _root = new Node(kv);
            return true;
        }
        Node* parent = nullptr;
        Node* cur = _root;
        // æŸ¥æ‰¾æ’å…¥ä½ç½®
        while(cur) {
            if (cur->_kv.first > kv.first) {
                parent = cur;
                cur = cur->_left;
            } else if (cur->_kv.first < kv.first) {
                parent = cur;
                cur = cur->_right;
            } else {
                return false;
            }
        }
        cur = new Node(kv);
        // æ’å…¥æ–°èŠ‚ç‚¹
        if (parent->_kv.first > kv.first) {
            parent->_left = cur;
        } else if (parent->_kv.first < kv.first) {
            parent->_right = cur;
        }
        cur->_parent = parent;

        // æ›´æ–°å¹³è¡¡å› å­
        while (parent) {
            if (cur == parent->_right) {
                parent->_bf++;
            } else {
                parent->_bf--;
            }

            if (parent->_bf == 1 || parent->_bf == -1) {
                parent = parent->_parent;
                cur = cur->_parent;
            } else if (parent->_bf == 0) {
                break;
            } else if (parent->_bf == 2 || parent->_bf == -2) {
                // æ—‹è½¬è°ƒæ•´å¹³è¡¡
                if (parent->_bf == 2 && cur->_bf == 1) {
                    RotateL(parent); // å·¦å•æ—‹
                } else if (parent->_bf == -2 && cur->_bf == -1) {
                    RotateR(parent); // å³å•æ—‹
                } else if (parent->_bf == -2 && cur->_bf == 1) {
                    RotateLR(parent); // å·¦å³åŒæ—‹
                } else if (parent->_bf == 2 && cur->_bf == -1) {
                    RotateRL(parent); // å³å·¦åŒæ—‹
                }
                break;
            } else {
                assert(false);
            }
        }
        return true;
    }

    // ä¸­åºéå†AVLæ ‘
    void InOrder() {
        _InOrder(_root);
        cout << endl;
    }
    // é€’å½’ä¸­åºéå†è¾…åŠ©å‡½æ•°
    void _InOrder(Node* root) {
        if (root == nullptr) return;
        _InOrder(root->_left);
        cout << root->_kv.first << " ";
        _InOrder(root->_right);
    }

    // åˆ¤æ–­AVLæ ‘æ˜¯å¦å¹³è¡¡
    bool IsBalance() {
        return _IsBalance(_root);
    }

private:
    Node* _root = nullptr;

    // å·¦å•æ—‹
    void RotateL(Node* parent) {
        Node* subR = parent->_right;
        Node* subRL = subR->_left;

        // å¤„ç† subRL ä¸ parent çš„è¿æ¥
        parent->_right = subRL;
        if (subRL) {
            subRL->_parent = parent;
        }

        // ä¿å­˜åŸçˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
        Node* pparent = parent->_parent;

        // å¤„ç† subR ä¸ parent çš„è¿æ¥
        subR->_left = parent;
        parent->_parent = subR;

        // å¤„ç† subR ä¸ pparent çš„è¿æ¥
        if (pparent == nullptr) {
            _root = subR;
            subR->_parent = nullptr;
        } else {
            if (pparent->_left == parent) {
                pparent->_left = subR;
            } else {
                pparent->_right = subR;
            }
            subR->_parent = pparent;
        }

        // æ›´æ–°å¹³è¡¡å› å­
        parent->_bf = subR->_bf = 0;
    }

    // å³å•æ—‹
    void RotateR(Node* parent) {
        Node* subL = parent->_left;
        Node* subLR = subL->_right;

        // å¤„ç† subLR ä¸ parent çš„è¿æ¥
        parent->_left = subLR;
        if (subLR) {
            subLR->_parent = parent;
        }

        // ä¿å­˜åŸçˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
        Node* pparent = parent->_parent;

        // å¤„ç† subL ä¸ parent çš„è¿æ¥
        subL->_right = parent;
        parent->_parent = subL;

        // å¤„ç† subL ä¸ pparent çš„è¿æ¥
        if (pparent == nullptr) {
            _root = subL;
            subL->_parent = nullptr;
        } else {
            if (pparent->_left == parent) {
                pparent->_left = subL;
            } else {
                pparent->_right = subL;
            }
            subL->_parent = pparent;
        }

        // æ›´æ–°å¹³è¡¡å› å­
        parent->_bf = subL->_bf = 0;
    }

    // å·¦å³åŒæ—‹
    void RotateLR(Node* parent) {
        Node* subL = parent->_left;
        Node* subLR = subL->_right;

        RotateL(parent->_left);
        RotateR(parent);
        int bf = subLR->_bf;

        // æ ¹æ®subLRçš„å¹³è¡¡å› å­æ›´æ–°å„èŠ‚ç‚¹å¹³è¡¡å› å­
        if (bf == 1) {
            parent->_bf = -1;
            subLR->_bf = 0;
            subL->_bf = -1;
        } else if (bf == -1) {
            parent->_bf = 1;
            subLR->_bf = 0;
            subL->_bf = -1;
        } else if (bf == 0) {
            parent->_bf = 0;
            subLR->_bf = 0;
            subL->_bf = 0;
        } else {
            assert(false);
        }
    }

    // å³å·¦åŒæ—‹
    void RotateRL(Node* parent) {
        Node* subR = parent->_right;
        Node* subRL = subR->_left;

        RotateR(parent->_right);
        RotateL(parent);
        int bf = subRL->_bf;

        // æ ¹æ®subRLçš„å¹³è¡¡å› å­æ›´æ–°å„èŠ‚ç‚¹å¹³è¡¡å› å­
        if (bf == 1) {
            parent->_bf = -1;
            subRL->_bf = 0;
            subR->_bf = 0;
        } else if (bf == -1) {
            parent->_bf = 0;
            subRL->_bf = 0;
            subR->_bf = 1;
        } else if (bf == 0) {
            parent->_bf = 0;
            subRL->_bf = 0;
            subR->_bf = 0;
        } else {
            assert(false);
        }
    }

    // è®¡ç®—æ ‘çš„é«˜åº¦
    int _Height(Node* root) {
        if(root == nullptr) { return 0; }
        int leftH = _Height(root->_left);
        int rightH = _Height(root->_right);

        return leftH > rightH ? leftH + 1 : rightH + 1;
    }

    // åˆ¤æ–­ä»¥rootä¸ºæ ¹çš„å­æ ‘æ˜¯å¦å¹³è¡¡
    bool _IsBalance(Node* root) {
        if (root == nullptr) { return true; }
        return abs(_Height(root->_left) - _Height(root->_right)) < 2
            && _IsBalance(root->_left) && _IsBalance(root->_right);
    }
};

// æµ‹è¯•AVLæ ‘çš„æ’å…¥å’Œå¹³è¡¡æ€§
void test_AVLTree() {
    int a[] = { 16, 3, 7, 11, 9, 26, 18, 14, 15 };
    AVLTree<int, int> t1;
    for (auto e : a) {
        t1.Insert(make_pair(e, e));
    }

    t1.InOrder();
    cout << t1.IsBalance() << endl;
}
```

ï¼ˆå°è¯•æ‹¿deepseekä¸°å¯Œå‰é¢çš„æ–‡æ¡ˆã€‚ï¼‰