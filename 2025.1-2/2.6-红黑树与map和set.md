# 2.6-红黑树与map和set

*由于map和set的底层和红黑树联系紧密，就放一起写了。*

## 迭代器

```c++
// 迭代器
template<class T, class Ref, class ptr> 
struct __RBIterator {
    typedef RBNode<T> Node;
    typedef __RBIterator<T, Ref, ptr> self;

    Node* _node;

    // 构造函数
    __RBIterator(Node* node) : _node(node) {}

    // 解引用运算符重载
    Ref operator*() {
        return _node->data;
    }

    // 箭头运算符重载
    ptr operator->() {
        return &_node->data;
    }

    // 不等比较运算符重载
    bool operator!=(const self& s) {
        return _node != s._node;
    }

    // 前置自增运算符重载
    self& operator++() {
        if (_node->_right) {
            // 1. 右不为空，下一个就是右子树的最左节点。
            Node *subLeft = _node->_right;
            while (subLeft->_left) {
                subLeft = subLeft->_left;
            }
            _node = subLeft;
        } else {
            // 右为空，沿着到根的路径，找到孩子是父亲左的那个祖先
            Node* cur = _node;
            Node *parent = cur->_parent;
            while (parent && cur == parent->_right) {
                cur = parent;
                parent = parent->_parent;
            }
            _node = parent;
        }
        return *this;
    }

    // 前置自减运算符重载
    self& operator--() {
        if (_node->_left) {
            // 1. 左不为空，下一个就是左子树的最右节点。
            Node* subRight = _node->_left;
            while (subRight->_right) {
                subRight = subRight->_right;
            }
            _node = subRight;
        } else {
            // 左为空，沿着到根的路径，找到孩子是父亲右的那个祖先
            Node* cur = _node;
            Node *parent = cur->_parent;
            while (parent && cur == parent->_left) {
                cur = parent;
                parent = parent->_parent;
            }
            _node = parent;
        }
        return *this;
    }
};
```



## 红黑树

```cpp
// 定义红黑树节点颜色
enum class Color { RED, BLACK };

// 红黑树节点结构体
template <typename T>
struct RBNode {
    T data;
    Color color;
    std::shared_ptr<RBNode<T>> left, right, parent;

    RBNode(const T& value) : data(value), color(Color::RED), left(nullptr), right(nullptr), parent(nullptr) {}
};

// 红黑树类
template <typename T, typename KeyOfValue, typename Compare = std::less<typename KeyOfValue::result_type>>
class RBTree {
private:
    std::shared_ptr<RBNode<T>> root;
    KeyOfValue keyOfValue;
    Compare compare;

    // 左旋操作
    void leftRotate(std::shared_ptr<RBNode<T>> x) {
        auto y = x->right;
        x->right = y->left;
        if (y->left) y->left->parent = x;
        y->parent = x->parent;
        if (!x->parent) root = y;
        else if (x == x->parent->left) x->parent->left = y;
        else x->parent->right = y;
        y->left = x;
        x->parent = y;
    }

    // 右旋操作
    void rightRotate(std::shared_ptr<RBNode<T>> y) {
        auto x = y->left;
        y->left = x->right;
        if (x->right) x->right->parent = y;
        x->parent = y->parent;
        if (!y->parent) root = x;
        else if (y == y->parent->right) y->parent->right = x;
        else y->parent->left = x;
        x->right = y;
        y->parent = x;
    }

    // 插入修复
    void insertFixup(std::shared_ptr<RBNode<T>> z) {
        while (z->parent && z->parent->color == Color::RED) {
            if (z->parent == z->parent->parent->left) {
                auto y = z->parent->parent->right;
                if (y && y->color == Color::RED) {
                    z->parent->color = Color::BLACK;
                    y->color = Color::BLACK;
                    z->parent->parent->color = Color::RED;
                    z = z->parent->parent;
                } else {
                    if (z == z->parent->right) {
                        z = z->parent;
                        leftRotate(z);
                    }
                    z->parent->color = Color::BLACK;
                    z->parent->parent->color = Color::RED;
                    rightRotate(z->parent->parent);
                }
            } else {
                auto y = z->parent->parent->left;
                if (y && y->color == Color::RED) {
                    z->parent->color = Color::BLACK;
                    y->color = Color::BLACK;
                    z->parent->parent->color = Color::RED;
                    z = z->parent->parent;
                } else {
                    if (z == z->parent->left) {
                        z = z->parent;
                        rightRotate(z);
                    }
                    z->parent->color = Color::BLACK;
                    z->parent->parent->color = Color::RED;
                    leftRotate(z->parent->parent);
                }
            }
        }
        root->color = Color::BLACK;
    }

public:
    // 插入操作
    void insert(const T& value) {
        auto z = std::make_shared<RBNode<T>>(value);
        std::shared_ptr<RBNode<T>> y = nullptr;
        auto x = root;

        while (x) {
            y = x;
            if (compare(keyOfValue(z->data), keyOfValue(x->data)))
                x = x->left;
            else
                x = x->right;
        }

        z->parent = y;
        if (!y)
            root = z;
        else if (compare(keyOfValue(z->data), keyOfValue(y->data)))
            y->left = z;
        else
            y->right = z;

        insertFixup(z);
    }

    // 查找操作
    std::shared_ptr<RBNode<T>> find(const typename KeyOfValue::result_type& key) {
        auto x = root;
        while (x) {
            if (compare(key, keyOfValue(x->data)))
                x = x->left;
            else if (compare(keyOfValue(x->data), key))
                x = x->right;
            else
                return x;
        }
        return nullptr;
    }
};

// 从 pair 中提取键的函数对象
template <typename Pair>
struct Select1st {
    using result_type = typename Pair::first_type;
    const result_type& operator()(const Pair& p) const {
        return p.first;
    }
};

// Identity 函数对象，用于 set
template <typename T>
struct Identity {
    using result_type = T;
    const T& operator()(const T& x) const {
        return x;
    }
};
```

## map类

```c++
// 自定义 map 类
template <typename Key, typename T, typename Compare = std::less<Key>>
class MyMap {
private:
    using Value = std::pair<const Key, T>;
    RBTree<Value, Select1st<Value>, Compare> tree;

public:
    // 插入操作
    void insert(const std::pair<Key, T>& value) {
        tree.insert(value);
    }

    // 方括号操作符重载
    T& operator[](const Key& key) {
        auto node = tree.find(key);
        if (!node) {
            insert({key, T()});
            node = tree.find(key);
        }
        return const_cast<T&>(node->data.second);
    }
};
```

## set类

```c++
// 自定义 set 类
template <typename T, typename Compare = std::less<T>>
class MySet {
private:
    RBTree<T, Identity<T>, Compare> tree;

public:
    // 插入操作
    void insert(const T& value) {
        tree.insert(value);
    }

    // 查找操作
    bool contains(const T& value) {
        return tree.find(value) != nullptr;
    }
};

int main() {
    // 测试 MyMap
    MyMap<int, std::string> myMap;
    myMap.insert({1, "one"});
    myMap[2] = "two";
    std::cout << "Map value at key 2: " << myMap[2] << std::endl;

    // 测试 MySet
    MySet<int> mySet;
    mySet.insert(10);
    std::cout << "Set contains 10: " << (mySet.contains(10) ? "Yes" : "No") << std::endl;

    return 0;
}
```

