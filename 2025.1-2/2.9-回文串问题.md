# Code-2.9-回文串问题

## [LCR 020. 回文子串](https://leetcode.cn/problems/a7VOhD/)

**分析**：中心扩展比较简单，马拉车效率比较高，但是动态规划也挺简单的。

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int n = s.length();
        vector<vector<bool>> dp(n, vector<bool>(n, false));

        int sum = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i + 1; j++) {
                if (s[i] == s[j]) {
                    if (i == j) {
                        dp[i][j] = true;
                    } else if (j + 1 == i) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i - 1][j + 1];
                    }

                    sum += dp[i][j] == true ? 1 : 0;
                }
            }
        }
        return sum;

    }
};
```



## [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

**分析**：直接复制前面的代码。

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.length();
        vector<vector<bool>> dp(n, vector<bool>(n, false));


        int length = 0, begin = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i + 1; j++) {
                if (s[i] == s[j]) {
                    if (i == j) {
                        dp[i][j] = true;
                    } else if (j + 1 == i) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i - 1][j + 1];
                    }

                    if (dp[i][j] && i - j > length) {
                        length = i - j;
                        begin = j;
                    }
                }
            }
        }

        string ans;
        for (int i = 0; i < 1 + length; i++) ans.push_back(s[begin + i]);
        return ans;
    }
};
```



## [1745. 分割回文串 IV](https://leetcode.cn/problems/palindrome-partitioning-iv/)

**分析**：直接复制前面的代码。

```cpp
class Solution {
public:
    bool checkPartitioning(string s) {
        int n = s.length();
        vector<vector<bool>> dp(n, vector<bool>(n, false));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i + 1; j++) {
                if (s[i] == s[j]) {
                    if (i == j) {
                        dp[i][j] = true;
                    } else if (j + 1 == i) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i - 1][j + 1];
                    }
                }
            }
        }

        for (int i = 1; i < n - 1; i++) {
            for (int j = i; j < n - 1; j++) {
                if (dp[i - 1][0] && dp[j][i] && dp[n - 1][j + 1]) {
                    return true;
                }
            }
        }

        return false;
    }
};
```



## [LCR 094. 分割回文串 II](https://leetcode.cn/problems/omKAoA/)

**分析**：两次DP。

```cpp
class Solution {
public:
    int minCut(string s) {
        int n = s.length();
        vector<vector<bool>> dp(n, vector<bool>(n, false));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i + 1; j++) {
                if (s[i] == s[j]) {
                    if (i == j) {
                        dp[i][j] = true;
                    } else if (j + 1 == i) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i - 1][j + 1];
                    }
                }
            }
        }
        if (n == 1) return 0;
        vector<int> f(n, n - 1);
        f[0] = 0;
        f[1] = s[0] == s[1] ? 0 : 1;
        for (int i = 2; i < n; i++) {
            for (int j = i; j >= 0; j--) {
                if (dp[i][j]) {
                    if (j == 0) {
                        f[i] = 0;
                    } else {
                        f[i] = min(f[i], f[j - 1] + 1);
                    }
                }
            }
        }
        return f[n - 1];
    }
};
```



## [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

**分析**：这个跟之前的相比，需要多一个条件。

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.length();
        vector<vector<int>> dp(n, vector<int>(n, 1));

        for (int j = 0; j < n; j++) {
            for (int i = j; i > -1; i--) {
                if (s[i] == s[j]) {
                    if (i == j) {
                        dp[i][j] = 1;
                    } else if (i + 1 == j) {
                        dp[i][j] = 2;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1] + 2;
                    }
                } else if (s[i] != s[j]) {
                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);
                }
            }
        }

        return dp[0][n - 1];
    }
};
```



## [1312. 让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

**分析**：如果做了上一个，这个题可以秒掉，没什么变化。

```cpp
class Solution {
public:
    int minInsertions(string s) {
        int n = s.length();
        vector<vector<int>> dp(n, vector<int>(n, n / 2));

        for (int j = 0; j < n; j++) {
            for (int i = j; i > -1; i--) {
                if (s[i] == s[j]) {
                    if (i == j) {
                        dp[i][j] = 0;
                    } else if (i + 1 == j) {
                        dp[i][j] = s[i] == s[j] ? 0 : 1;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                } else {
                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
                }
            }
        }

        return dp[0][n - 1];
    }
};
```

