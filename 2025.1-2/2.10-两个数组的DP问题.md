# Code-2.9-两个数组的DP问题

## [LCR 095. 最长公共子序列](https://leetcode.cn/problems/qJnOS7/)

**分析**：经典题型。值得一提的是还有一个一模一样的题，做一道送一道，性价比超高。

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n1 = text1.length(), n2 = text2.length();
        int max_n = max(n1, n2);
        vector<vector<int>> dp(max_n + 1, vector<int>(max_n + 1, 0));
        for (int i = 1; i <= n1; i++) {
            for(int j = 1; j <= n2; j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }


        return dp[n1][n2];
    }
};
```



## [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)

**分析**：本题和上一题无区别。

```cpp
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();

        vector<vector<int>> dp(max(m, n) + 1, vector<int>(max(m, n) + 1));

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[m][n];
    }
};
```



## [LCR 097. 不同的子序列](https://leetcode.cn/problems/21dk04/)

**分析**：和上题区别不是很大，但是过程中可能溢出，所以需要用long long。

```cpp
#include <vector>
#include <string>

class Solution {
public:
    int numDistinct(string s, string t) {
        int s_length = s.length();
        int t_length = t.length();
        vector<vector<unsigned long long>> dp(s_length + 1, vector<unsigned long long>(t_length + 1, 0));

        for (int i = 0; i <= s_length; ++i) {
            dp[i][0] = 1;
        }
        for (int i = 1; i <= s_length; ++i) {
            for (int j = 1; j <= t_length; ++j) {
                dp[i][j] = dp[i - 1][j];
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] += dp[i - 1][j - 1];
                }
            }
        }
        return static_cast<int>(dp[s_length][t_length]);
    }
};
```



## [44. 通配符匹配](https://leetcode.cn/problems/wildcard-matching/)

**分析**：当字符是`'*'`时，需要保留`'*'`以留给上一次dp。

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.length(), n = p.length();

        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));
        dp[0][0] = true;
        for (int i = 1; i < n + 1; i++){
            if (p[i - 1] == '*') {
                dp[0][i] = true;
            } else {
                break;
            }
        }
        for (int i = 1; i < m + 1; i++) {
            for(int j = 1; j < n + 1; j++) {
                if (s[i - 1] == p[j - 1] || p[j - 1] == '?') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p[j - 1] == '*'){
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j]; 
                }
            }
        }

        return dp[m][n];
    }
};
```



## [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

**分析**：如果研究明白了上一个，那么这题不算难。

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.length(), n = p.length();
        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));
        dp[0][0] = true;
        for (int i = 1; i < n + 1; i++) {
            if (p[i - 1] == '*') {
                dp[0][i] = dp[0][i - 2];
            }
        }
        for (int i = 1; i < m + 1; i++) {
            for(int j = 1; j < n + 1; j++) {
                if (s[i - 1] == p[j - 1] || p[j - 1] == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p[j - 1] == '*'){
                    if (p[j - 2] == '.' || p[j - 2] == s[i - 1]) {
                        dp[i][j] = dp[i][j - 2] || dp[i - 1][j];
                    } else {
                        dp[i][j] = dp[i][j - 2];
                    }
                }
            }
        }
        return dp[m][n];
    }
};
```



## [97. 交错字符串](https://leetcode.cn/problems/interleaving-string/)

```cpp
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();
        if(n3 != n1 + n2) return false;
        s1 = " " + s1, s2 = " " + s2, s3 = " " + s3;

        vector<vector<bool>> dp(n1 + 1, vector<bool>(n2 + 1, false));
        dp[0][0] = true;
        for (int i = 1; i < n1 + 1; ++i) {
            if (s1[i] == s3[i]) {
                dp[i][0] = true;
            } else {
                break;
            }
        }

        for (int i = 1; i < n2 + 1; ++i) {

            if (s2[i] == s3[i]) {
                dp[0][i] = true;
            } else {
                break;
            }
        }

        for (int i = 1; i < n1 + 1; ++i) {
            for (int j = 1; j < n2 + 1; ++j) {
                if (s3[i + j] == s1[i]) {
                    dp[i][j] = dp[i][j] || dp[i - 1][j];
                }
                if (s3[i + j] == s2[j]) {
                    dp[i][j] = dp[i][j] || dp[i][j - 1];
                }
            }
        }


        return dp[n1][n2];

    }
};
```



## [712. 两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/)

**分析**：挺简单的。

```cpp
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int m = s1.size(), n = s2.size();

        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        dp[0][0] = 0;

        for (int i = 1; i < m + 1; ++i) {
            dp[i][0] = dp[i - 1][0] + (int)s1[i - 1];
        }
        
        for (int i = 1; i < n + 1; ++i) {
            dp[0][i] = dp[0][i - 1] + (int)s2[i - 1];
        }

        for (int i = 1; i < m + 1; ++i) {
            for (int j = 1; j < n + 1; ++j) {
                if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(dp[i - 1][j] + (int)s1[i - 1],
                    dp[i][j - 1] + (int)s2[j - 1]);
                }
            }
        }

        return dp[m][n];
    }
};
```



## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

**分析**：这个和上一个几乎是一样的。

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        // 初始化
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        // 处理边界
        for (int i = 1; i < m + 1; i++) {
            dp[i][0] = dp[i - 1][0] + 1;
        }

        for (int j = 1; j < n + 1; j++) {
            dp[0][j] = dp[0][j - 1] + 1;
        }

        for(int i = 1; i < m + 1; ++i) {
            for (int j = 1; j < n + 1; ++j) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + 1);
                }
            }
        }

        return dp[m][n];
    }
};
```



## [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

**分析**：做过前面的，此题是较为简单的。

```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();
        // 创建dp表。
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));

        int ret = 0;
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = 0;
                }

                ret = max(ret, dp[i][j]);
            }
        }
        return ret; 
    }
};
```

