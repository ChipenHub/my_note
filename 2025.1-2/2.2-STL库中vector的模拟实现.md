# 2.1-STL库中vector的模拟实现

对于C++的类和对象中一些零碎复杂的语法规则，我用模拟实现STL库中常见类和模板总结。

对于迭代器部分，我先提供一段stl源码中的定义方式。

```cpp
public:
    typedef T value_type;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;

    iterator start;
    iterator finish;
    iterator end_of_storage;
}

vector() : start(0), finish(0), end_of_storage(0) {}
size_type size() const { return size_type(end() - begin()); }
size_type capacity() const { return size_type(end_of_storage - begin()); }
iterator begin() { return start; }
iterator end() { return finish; }
```

本文中模拟了vector中的大部分常用接口，如尾插，中间的插入删除，reserve和resize以及运算符重载。

为了能提供可直接运行的代码，接下来的内容在代码块中完成。

```cpp
#include <iostream>
#include <cstring>
#include <assert.h>
#include <algorithm>

namespace vec {
    template<class T>
    class my_vector {
    public:
        typedef T* iterator;
        typedef const T* const_iterator;

        // 迭代器
        const_iterator begin() const { return _start; }
        const_iterator end() const { return _finish; }
        iterator begin() { return _start; }
        iterator end() { return _finish; }

        // 构造函数
        my_vector() {}
        my_vector(size_t n, const T& x = T()) {
            resize(n, x);
        }
        my_vector(int n, const T& x = T()) {
            resize(n, x);
        }

        template<class InputIterator>
        my_vector(InputIterator first, InputIterator last) {
            while (first != last) {
                push_back(*first);
                first++;
            }
        }
        

        // 拷贝构造函数
        my_vector(const my_vector& other) : _start(nullptr), _finish(nullptr), _end_of_storage(nullptr) {
            reserve(other.size());
            for (size_t i = 0; i < other.size(); ++i) {
                push_back(other[i]); // 使用 push_back 确保深拷贝
            }
        }

        // 赋值运算符重载
        my_vector& operator=(const my_vector& other) {
            if (this != &other) {
                my_vector tmp(other); // 拷贝构造
                swap(tmp); // 交换资源
            }
            return *this;
        }

        // 析构函数
        ~my_vector() {
            clear();
            delete[] _start;
        }

        // 交换
        void swap(my_vector& other) {
            std::swap(_start, other._start);
            std::swap(_finish, other._finish);
            std::swap(_end_of_storage, other._end_of_storage);
        }

        // 清空容器
        void clear() {
            for (iterator it = _start; it != _finish; ++it) {
                it->~T(); // 显式调用析构函数
            }
            _finish = _start;
        }

        size_t capacity() const { return _end_of_storage - _start; }
        size_t size() const { return _finish - _start; }

        // reserve
        void reserve(size_t n) {
            if (capacity() < n) {
                size_t s = size();
                T* tmp = new T[n];
                for (size_t i = 0; i < s; ++i) {
                        tmp[i] = _start[i]; // 使用赋值操作确保深拷贝
                    }
                delete[] _start;
                _start = tmp;
                _finish = _start + s;
                _end_of_storage = _start + n;
            }
        }

        // 下标访问
        T& operator[](size_t pos) { return _start[pos]; }
        const T& operator[](size_t pos) const { return _start[pos]; }

        // 尾插
        void push_back(const T& x) {
            if (_finish == _end_of_storage) {
                reserve(capacity() == 0 ? 4 : capacity() * 2);
            }
            *_finish = x;
            ++_finish;
        }

        // 判断是否为空
        bool empty() const { return _start == _finish; }

        // 尾删
        void pop_back() {
            assert(!empty());
            --_finish;
        }

        // resize
        void resize(size_t n, T x = T()) {
            size_t s = size();
            if (n < s) {
                _finish = _start + n;
            } else if (n > s) {
                reserve(n);
                for (size_t i = s; i < n; ++i) {
                    *(_start + i) = x;
                }
                _finish = _start + n;
            }
        }

        iterator insert(iterator pos, const T& x) {
            assert(pos <= _finish && pos >= _start);
            if (_finish == _end_of_storage) {
                size_t len = pos - _start;
                reserve(capacity() == 0 ? 4 : capacity() * 2);
                pos = _start + len;
            }
            iterator end = _finish - 1;
            while(end >= pos) {
                *(end + 1) = *(end);
                end--;
            }
            *(pos) = x;
            _finish++;

            return pos;
        }

        // 中间删除
        void erase(iterator pos) {
            assert(pos <= _finish && pos >= _start);
            iterator start = pos + 1;
            while (start <= _finish) {
                *(start - 1) = *start;
                start++;
            }
            --_finish;
        }


        // 打印
        void print() const {
            for (const_iterator it = begin(); it != end(); ++it) {
                std::cout << *it << " ";
            }
            std::cout << std::endl;
        }

    private:
        iterator _start = nullptr;
        iterator _finish = nullptr;
        iterator _end_of_storage = nullptr;
    };

    void test_vector1() {
        my_vector<int> v;
        v.push_back(1);
        v.push_back(1);
        v.push_back(1);
        v.push_back(1);
        v.push_back(1);

        // 测试尾插和迭代器
        for (auto e : v) {
            std::cout << e << " ";
        }
        std::cout << std::endl;

        // 测试 resize
        v.resize(8, 2);
        v.print();
    }


    void test_vector2() {
        my_vector<int> v;
        v.push_back(1);
        v.push_back(4);
        v.push_back(3);
        v.insert(v.begin(), 0);
        v.print(); // 0 1 4 3
        my_vector<int>::iterator it = std::find(v.begin(), v.end(), 4);
        v.insert(it, 40);
        // 值得注意的是，此时pos已经失效，我们称此现象为典型的迭代器失效。
        // 解决方法，用it接受一遍insert的返回值。
        v.print(); // 0 1 40 4 3
        it = std::find(v.begin(), v.end(), 4);
        v.erase(it);
        v.print(); // 0 1 40 3
    }

    void test_vector3() {
        // 再次测试构造函数。
        my_vector<int> v1(10, 5);
        v1.print(); // 十个5
        my_vector<int> v2((v1.begin() + 1), (v1.end() - 2));
        v2.print(); // 七个5

        std::string s = "hello";
        my_vector<int> v3(s.begin(), s.end());
        v3.print();

        int a[] = {10, 20, 30};
        my_vector<int> v4(a, a + 3);
        v4.print();
    }
}
```