# DPDK（25.03）：Win <-> Linux 虚拟机收发过程的实现解析与问题分析

在我学习 DPDK 的网卡接管后与局域网内设备进行通信的时候遇到了一些问题，本文进行一系列汇总以供参考。

问题一：为什么 DPDK 的程序不能直接用网卡 IP 收发数据？

问题二：什么是 arp？如何配置 arp 才能与 DPDK 的程序通信？

问题三：VMware 的虚拟网卡是如何借助物理网卡通信的？

## 收发代码

DPDK 初始化网卡端口通常遵循以下步骤：

**初始化 EAL**：

- 调用 `rte_eal_init()` 初始化 DPDK 环境（大页内存、NUMA、驱动等）。

**探测网卡**：

- 使用 `rte_eth_dev_count_avail()` 获取可用端口数量。

**配置端口**：

- 调用 `rte_eth_dev_configure(port_id, nb_rx_queues, nb_tx_queues, &eth_conf)` 配置端口的队列数量和参数。

**配置 RX/TX 队列**：

- 调用 `rte_eth_rx_queue_setup()` 配置接收队列。
- 调用 `rte_eth_tx_queue_setup()` 配置发送队列。

**启动端口**：

- 调用 `rte_eth_dev_start(port_id)` 启动端口，使网卡开始工作。

**（可选）检查链路状态**：

- 使用 `rte_eth_link_get()` 或 `rte_eth_link_get_nowait()` 检查链路状态。

**开始数据包处理**：

- 使用 `rte_eth_rx_burst()` 和 `rte_eth_tx_burst()` 接收和发送数据包。



+ `rte_eal_init(int argc, char **argv)` 

  + 初始化 EAL 环境。必须在任何 DPDK 之前调用。
  + EAL（Environment Abstraction Layer） 是 DPDK（Data Plane Development Kit）中的环境抽象层，负责初始化和管理底层系统资源，为 DPDK 应用提供统一的运行环境。它屏蔽了操作系统和硬件的差异，确保 DPDK 程序在不同平台（如 Linux、FreeBSD）上的可移植性。

+ `static uint16_t gDpdkPortId = 0;`

  + 在 DPDK 程序中，对于网卡的描述不使用具体的网卡名称、Mac地址或PCI，而是依靠一个逻辑端口，可利用 `testpmd` 等工具查询。本程序使用 0 端口对应的网卡

+ `rte_eth_dev_socket_id(uint16_t port_id)`

  + 用于返回当前网卡逻辑端口所在内存的 NUMA 节点。
  + NUMA（Non-Uniform Memory Access，非均匀内存访问）是一种计算机内存架构，广泛用于多核处理器系统，尤其是服务器和工作站。

+ `rte_eth_promiscuous_enable(uint16_t port_id)`

  + 混杂模式，将会接受所有经过 `port_id` 端口的数据。

+ ```cpp
  struct rte_mbuf *bufs[PKT_BURST];
  uint16_t nb_rx = rte_eth_rx_burst(gDpdkPortId, 0, bufs, PKT_BURST);
  for (uint16_t i = 0; i < nb_rx; i++) {
      process_packet(bufs[i], gDpdkPortId);
  }
  ```

  + 此处含义为，在一次 burst 以前，数据存放在网卡的队列中，队列中存放指向 `rte_mbuf` 的描述符，一次 burst 收集所有描述符，每个包都是独立的带有完整协议栈的。

+ `rte_pktmbuf_mtod`

  + 将 `rte_mbuf` 指针转换为指向数据包实际数据（payload）的指针。
    + mtod -> m_buf to data