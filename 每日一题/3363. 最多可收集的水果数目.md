
> Problem: [3363. 最多可收集的水果数目](https://leetcode.cn/problems/find-the-maximum-number-of-fruits-collected/description/)

[TOC]

# 思路

> dp 三次即可，三人路线不会重合，可以只开一个数组。

# 解题过程

> 先填写对角线，然后改变遍历方式填写两种方式到达重点的 dp 表即可。

# 复杂度

- 时间复杂度: $O(n ^ 2)$
- 空间复杂度: $O(n ^ 2)$



# Code
```cpp
class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        
        vector<vector<int>> f(n + 2, vector<int>(n + 2, 0));
        
        for (int i = 1; i < n; i++) {
            f[i][i] = f[i - 1][i - 1] + fruits[i - 1][i - 1];
        }

        for (int i = 1; i < n; i++) {

            for (int j = 0; j < min(i, n - i); j++) { // 不跨过对角线
                int x = n - j;
                f[i][x] = max({
                    f[i - 1][x], 
                    f[i - 1][x - 1], 
                    f[i - 1][x + 1]
                }) + fruits[i - 1][x - 1];
            }
        }

        for (int i = 1; i < n; i++) {

            for (int j = 0; j < min(i, n - i); j++) {
                int y = n - j;
                f[y][i] = max({
                    f[y][i - 1],
                    f[y - 1][i - 1],
                    f[y + 1][i - 1]
                }) + fruits[y - 1][i - 1];
            }
        }

        return f[n - 1][n - 1] + f[n - 1][n] + f[n][n - 1] + fruits[n - 1][n - 1];
    }
};
```
