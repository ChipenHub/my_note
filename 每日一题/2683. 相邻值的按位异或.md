
> Problem: [2683. 相邻值的按位异或](https://leetcode.cn/problems/neighboring-bitwise-xor/description/)

[TOC]

# 思路

> 用递归调用模拟每一次的选择过程。
# 解题过程

> 每次选择结束后，传给下一次本次的结果以及下一次的预测结果。
# 复杂度

- 时间复杂度: $O(n)$
- 空间复杂度: $O(n)$



# Code
```C++ []
class Solution {
public:

    int n = 0;
    bool fir = 0;
    int ways = 0;

    void dfs(vector<int>& derived, bool head, int ind, bool cur, bool next) {

        if (ind == n) {

            if (next != head) return;

            ways++;
            return;

        }


        if (derived[ind] == 0) {

            if (next == 1) dfs(derived, head, ind + 1, 1, 1);
            if (next == 0) dfs(derived, head, ind + 1, 0, 0);

        } else {

            if (next == 1) dfs(derived, head, ind + 1, 1, 0);
            if (next == 0) dfs(derived, head, ind + 1, 0, 1);

        }

    }

    bool doesValidArrayExist(vector<int>& derived) {
        n = derived.size();

        if (derived[0] == 0) {

            dfs(derived, 0, 1, 0, 0);
            dfs(derived, 1, 1, 1, 1);

        } else {

            dfs(derived, 1, 1, 1, 0);
            dfs(derived, 0, 1, 0, 1);

        }

        return ways > 0;
    }
};
```
