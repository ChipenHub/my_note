> Problem: [1504. 统计全 1 子矩形](https://leetcode.cn/problems/count-submatrices-with-all-ones/description/)

[TOC]

# 思路

> 将长度数据存储为数组。

# 解题过程

> 首先存储每一个位置能向左延申的最长的连续 `1` 的长度为f，然后遍历每一个f的同一列的每一行，每次更新 `cur` 为每次遍历的最小长度并且添加到结果中.

# 复杂度

- 时间复杂度: $O(M * N)$

- 空间复杂度: $O(N^2)$

# Code

```cpp
class Solution {

public:

    int numSubmat(vector<vector<int>>& mat) {

        int m = mat.size(), n = mat[0].size();



        int ret = 0;

        vector<vector<int>> f(m, vector<int>(n, 0));



        for (int i = 0; i < m; i++)

            for (int j = 0; j < n; j++) {



                if (j) f[i][j] = mat[i][j] ? f[i][j - 1] + 1 : 0;

                else f[i][j] = mat[i][j];



                int cur = f[i][j];

                for (int k = i; k >=0; k--) {



                    cur = min(cur, f[k][j]);

                    if (!cur) break;

                    ret += cur;



                }



            }



            return ret;

    }

};
```
