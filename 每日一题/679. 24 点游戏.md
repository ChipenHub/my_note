> Problem: [679. 24 点游戏](https://leetcode.cn/problems/24-game/description/)

[TOC]

# 思路

> 深度优先搜索。

# 解题过程

> 维护一个数组，运算一次会减少一个数字卡片，当只剩下一个卡片的时候检查是否为 `24` 即可。

# 复杂度

- 时间复杂度: $O(1)$

- 空间复杂度: $O(1)$

# Code

```cpp
class Solution {

public:



    const int AIM = 24;

    const double EPS = 1e-6;



    bool judgePoint24(vector<int>& cards) {

        vector<double> way;

        for (auto &n : cards) {



            way.emplace_back(static_cast<double>(n));



        }



        return dfs(way);

    }




    bool dfs(vector<double> &w) {



        int s = w.size();



        if (s == 0) return false;

        if (s == 1) return fabs(w[0] - AIM) < EPS;



        for (int i = 0; i < s; i++)

            for (int j = 0; j < s; j++)

                if (i != j) {



                    vector<double> ww = vector<double>();



                    for (int k = 0; k < s; k++)

                        if (k != i && k != j)

                            ww.emplace_back(w[k]);



                        if (i > j) {

                            ww.emplace_back(w[i] + w[j]);

                            if (dfs(ww)) return true;

                            ww.pop_back();



                            ww.emplace_back(w[i] * w[j]);

                            if (dfs(ww)) return true;

                            ww.pop_back();

                        }



                        ww.emplace_back(w[i] - w[j]);

                        if (dfs(ww)) return true;

                        ww.pop_back();



                        if (fabs(w[j]) > EPS) {

                            ww.emplace_back(w[i] / w[j]);

                            if (dfs(ww)) return true;

                            ww.pop_back();

                        }



                }



        return false;



    }

};
```
