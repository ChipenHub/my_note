
> Problem: [3479. 水果成篮 III](https://leetcode.cn/problems/fruits-into-baskets-iii/description/)

[TOC]

# 思路

> 线段树维护区间最大值。

# 解题过程

> 在每一次遍历水果时，先检查是否为叶子节点，如果是直接检查返回并更新线段树即可，如果不是叶子节点，先递归检查左孩子能否装下水果，不能则检查右孩子。

# 复杂度

- 时间复杂度: $O(n * logn)$
- 空间复杂度: $O(4 * n) = O(n)$



# Code
```Cpp
class Solution {
public:
    vector<int> tree;

    void build(vector<int>& baskets, int root, int l, int r) {
        if (l == r) {
            tree[root] = baskets[l];
            return;
        }

        int mid = (l + r) / 2;
        build(baskets, root * 2, l, mid);
        build(baskets, root * 2 + 1, mid + 1, r);
        tree[root] = max(tree[root * 2], tree[root * 2 + 1]);
    }

    void update(int root, int l, int r, int pos, int val) {
        if (l == r) {
            tree[root] = val;
            return;
        }

        int mid = (l + r) / 2;
        if (pos <= mid) update(root * 2, l, mid, pos, val);
        else update(root * 2 + 1, mid + 1, r, pos, val);

        tree[root] = max(tree[root * 2], tree[root * 2 + 1]);
    }

    int getLeft(vector<int>& baskets, int root, int l, int r, int fruit) {
        if (tree[root] < fruit) return -1;
        if (l == r) {
            int temp = baskets[l];
            baskets[l] = -1;
            update(1, 0, (int)baskets.size() - 1, l, -1);
            return temp;
        }

        int mid = (l + r) / 2;
        int res = getLeft(baskets, root * 2, l, mid, fruit);
        if (res != -1) return res;

        return getLeft(baskets, root * 2 + 1, mid + 1, r, fruit);
    }

    int numOfUnplacedFruits(vector<int>& fruits, vector<int>& baskets) {
        int n = baskets.size();
        tree.resize(n * 4);
        build(baskets, 1, 0, n - 1);
        int ret = 0;

        for (auto& fruit : fruits) {
            if (getLeft(baskets, 1, 0, n - 1, fruit) == -1) ret++;
        }

        return ret;
    }
};
```
