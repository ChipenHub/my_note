> Problem: [3197. 包含所有 1 的最小矩形面积 II](https://leetcode.cn/problems/find-the-minimum-area-to-cover-all-ones-ii/description/)

@[toc]

# 思路

> 先整体运算得到最大矩形然后考虑不同的方法分割成三个小的，再对每一个小的运算一次。

# 解题过程

> 先定义函数为运算出最小矩形面积，然后分别枚举不同切法，找出最小值即可。

# 复杂度

- 时间复杂度: $O(n^4)$
- 空间复杂度: $O(n ^ 2)$

# Code

```cpp
class Solution {
public:
    int minimumSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        // 预处理：getArea(r1,c1,r2,c2) 返回子矩阵中1的最小的包围矩形面积
        auto getArea = [&](int r1, int c1, int r2, int c2) -> int {
            if (r1 > r2 || c1 > c2) return 0;
            int minR = m, maxR = -1, minC = n, maxC = -1;
            bool found = false;
            for (int i = r1; i <= r2; i++) {
                for (int j = c1; j <= c2; j++) {
                    if (grid[i][j] == 1) {
                        found = true;
                        minR = min(minR, i);
                        maxR = max(maxR, i);
                        minC = min(minC, j);
                        maxC = max(maxC, j);
                    }
                }
            }
            if (!found) return 0;
            return (maxR - minR + 1) * (maxC - minC + 1);
        };

        int ans = INT_MAX;

        // 类型1：横向切两刀（三行块）
        for (int i = 0; i < m - 2; i++) {
            for (int j = i + 1; j < m - 1; j++) {
                int area1 = getArea(0, 0, i, n - 1);
                int area2 = getArea(i + 1, 0, j, n - 1);
                int area3 = getArea(j + 1, 0, m - 1, n - 1);
                ans = min(ans, area1 + area2 + area3);
            }
        }

        // 类型2：纵向切两刀（三列块）
        for (int i = 0; i < n - 2; i++) {
            for (int j = i + 1; j < n - 1; j++) {
                int area1 = getArea(0, 0, m - 1, i);
                int area2 = getArea(0, i + 1, m - 1, j);
                int area3 = getArea(0, j + 1, m - 1, n - 1);
                ans = min(ans, area1 + area2 + area3);
            }
        }

        // 类型3a：先竖切，再对左半部分横切
        // 左边再上下切
        for (int i = 0; i < n - 1; i++) {  // 竖切在第i列右边
            // 左上 + 左下 + 右
            for (int j = 0; j < m - 1; j++) {
                int top = getArea(0, 0, j, i);
                int bottom = getArea(j + 1, 0, m - 1, i);
                int right = getArea(0, i + 1, m - 1, n - 1);
                ans = min(ans, top + bottom + right);
            }
        }

        // 类型3b：先竖切，再对右半部分横切
        for (int i = 0; i < n - 1; i++) {
            // 左 + 右上 + 右下
            for (int j = 0; j < m - 1; j++) {
                int left = getArea(0, 0, m - 1, i);
                int top = getArea(0, i + 1, j, n - 1);
                int bottom = getArea(j + 1, i + 1, m - 1, n - 1);
                ans = min(ans, left + top + bottom);
            }
        }

        // 类型4a：先横切，再对上半部分竖切
        for (int i = 0; i < m - 1; i++) {
            // 上左 + 上右 + 下
            for (int j = 0; j < n - 1; j++) {
                int left = getArea(0, 0, i, j);
                int right = getArea(0, j + 1, i, n - 1);
                int bottom = getArea(i + 1, 0, m - 1, n - 1);
                ans = min(ans, left + right + bottom);
            }
        }

        // 类型4b：先横切，再对下半部分竖切
        for (int i = 0; i < m - 1; i++) {
            // 上 + 下左 + 下右
            for (int j = 0; j < n - 1; j++) {
                int top = getArea(0, 0, i, n - 1);
                int left = getArea(i + 1, 0, m - 1, j);
                int right = getArea(i + 1, j + 1, m - 1, n - 1);
                ans = min(ans, top + left + right);
            }
        }

        return ans;
    }
};
```
